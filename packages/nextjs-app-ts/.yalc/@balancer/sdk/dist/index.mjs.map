{"version":3,"sources":["../src/data/enrichers/onChainPoolDataEnricher.ts","../src/abi/balancerQueries.ts","../src/abi/sorQueries.ts","../src/entities/token.ts","../src/utils/constants.ts","../src/types.ts","../src/entities/path.ts","../src/entities/tokenAmount.ts","../src/entities/swap.ts","../src/utils/helpers.ts","../src/utils/math.ts","../src/utils/pool.ts","../src/utils/fetch.ts","../src/data/providers/subgraphPoolProvider.ts","../src/utils/logger.ts","../src/pathGraph/pathGraph.ts","../src/router.ts","../src/entities/pools/weighted/weightedFactory.ts","../src/entities/pools/weighted/weightedPool.ts","../src/entities/pools/weighted/weightedMath.ts","../src/entities/pools/stable/stableFactory.ts","../src/entities/pools/stable/stablePool.ts","../src/entities/pools/stable/stableMath.ts","../src/entities/pools/metastable/metastableFactory.ts","../src/entities/pools/metastable/metastablePool.ts","../src/entities/pools/linear/linearFactory.ts","../src/entities/pools/linear/linearPool.ts","../src/entities/pools/linear/linearMath.ts","../src/entities/pools/parser.ts","../src/data/poolDataService.ts","../src/sor.ts","../src/static.ts"],"sourcesContent":["import { Address, createPublicClient, formatUnits, Hex, http } from 'viem';\nimport { sorQueriesAbi } from '../../abi/';\nimport {\n    GetPoolsResponse,\n    PoolDataEnricher,\n    RawPool,\n    RawPoolTokenWithRate,\n    RawWeightedPoolToken,\n} from '../types';\n\nimport {\n    poolHasActualSupply,\n    poolHasPercentFee,\n    poolHasVirtualSupply,\n    poolIsLinearPool,\n} from '../../utils';\nimport { HumanAmount, SwapOptions } from '../../types';\n\ninterface OnChainPoolData {\n    id: string;\n    balances: readonly bigint[];\n    totalSupply: bigint;\n    swapFee?: bigint;\n\n    amp?: bigint;\n    weights?: readonly bigint[];\n    wrappedTokenRate?: bigint;\n    scalingFactors?: readonly bigint[];\n}\n\nenum TotalSupplyType {\n    TOTAL_SUPPLY = 0,\n    VIRTUAL_SUPPLY = 1,\n    ACTUAL_SUPPLY = 2,\n}\n\nenum SwapFeeType {\n    SWAP_FEE_PERCENTAGE = 0,\n    PERCENT_FEE = 1,\n}\n\ninterface OnChainPoolDataQueryConfig {\n    loadTokenBalances: 'all' | 'updates-after-block' | 'none';\n    blockNumber: bigint;\n    loadTotalSupply: boolean;\n    loadSwapFees: boolean;\n    loadLinearWrappedTokenRates: boolean;\n    loadWeightsForPools: {\n        poolIds?: string[];\n        poolTypes?: string[];\n    };\n    loadAmpForPools: {\n        poolIds?: string[];\n        poolTypes?: string[];\n    };\n    loadScalingFactorForPools: {\n        poolIds?: string[];\n        poolTypes?: string[];\n    };\n}\n\nexport class OnChainPoolDataEnricher implements PoolDataEnricher {\n    private readonly config: OnChainPoolDataQueryConfig;\n\n    constructor(\n        private readonly rpcUrl: string,\n        private readonly sorQueriesAddress: Address,\n        config?: Partial<OnChainPoolDataQueryConfig>,\n    ) {\n        this.config = {\n            loadTokenBalances: 'updates-after-block',\n            blockNumber: 0n,\n            loadTotalSupply: true,\n            loadLinearWrappedTokenRates: true,\n            loadSwapFees: true,\n            loadAmpForPools: {},\n            loadScalingFactorForPools: {},\n            loadWeightsForPools: {},\n            ...config,\n        };\n    }\n\n    public async fetchAdditionalPoolData(\n        data: GetPoolsResponse,\n        options: SwapOptions,\n    ): Promise<OnChainPoolData[]> {\n        const rawPools = data.pools;\n\n        if (rawPools.length === 0) {\n            return [];\n        }\n\n        const {\n            poolIds,\n            weightedPoolIdxs,\n            ampPoolIdxs,\n            linearPoolIdxs,\n            totalSupplyTypes,\n            scalingFactorPoolIdxs,\n            swapFeeTypes,\n        } = this.getPoolDataQueryParams(data);\n\n        const client = createPublicClient({\n            transport: http(this.rpcUrl),\n        });\n\n        const [\n            balances,\n            totalSupplies,\n            swapFees,\n            linearWrappedTokenRates,\n            weights,\n            scalingFactors,\n            amps,\n        ] = await client.readContract({\n            address: this.sorQueriesAddress,\n            abi: sorQueriesAbi,\n            functionName: 'getPoolData',\n            args: [\n                poolIds,\n                {\n                    loadTokenBalanceUpdatesAfterBlock:\n                        this.config.loadTokenBalances !== 'none',\n                    loadTotalSupply: this.config.loadTotalSupply,\n                    loadSwapFees: this.config.loadSwapFees,\n                    loadLinearWrappedTokenRates:\n                        this.config.loadLinearWrappedTokenRates,\n                    loadNormalizedWeights: weightedPoolIdxs.length > 0,\n                    loadScalingFactors: scalingFactorPoolIdxs.length > 0,\n                    loadAmps: ampPoolIdxs.length > 0,\n                    blockNumber:\n                        data.syncedToBlockNumber &&\n                        this.config.loadTokenBalances === 'updates-after-block'\n                            ? data.syncedToBlockNumber\n                            : 0n,\n                    totalSupplyTypes,\n                    swapFeeTypes,\n                    linearPoolIdxs,\n                    weightedPoolIdxs,\n                    scalingFactorPoolIdxs,\n                    ampPoolIdxs,\n                },\n            ],\n            blockNumber: options.block,\n        });\n\n        return poolIds.map((_poolId, i) => ({\n            id: poolIds[i],\n            balances: balances[i],\n            totalSupply: totalSupplies[i],\n            weights: weightedPoolIdxs.includes(BigInt(i))\n                ? weights[weightedPoolIdxs.indexOf(BigInt(i))]\n                : undefined,\n            amp: ampPoolIdxs.includes(BigInt(i))\n                ? amps[ampPoolIdxs.indexOf(BigInt(i))]\n                : undefined,\n            wrappedTokenRate: linearPoolIdxs.includes(BigInt(i))\n                ? linearWrappedTokenRates[linearPoolIdxs.indexOf(BigInt(i))]\n                : undefined,\n            scalingFactors: scalingFactors[i],\n            swapFee: swapFees[i],\n        }));\n    }\n\n    public enrichPoolsWithData(\n        pools: RawPool[],\n        additionalPoolData: OnChainPoolData[],\n    ): RawPool[] {\n        return pools.map((pool) => {\n            const data = additionalPoolData.find((item) => item.id === pool.id);\n\n            return {\n                ...pool,\n                tokens: pool.tokens\n                    .sort((a, b) => a.index - b.index)\n                    .map((token) => {\n                        return {\n                            ...token,\n                            balance:\n                                data?.balances && data.balances.length > 0\n                                    ? (formatUnits(\n                                          data.balances[token.index],\n                                          token.decimals,\n                                      ) as HumanAmount)\n                                    : token.balance,\n                            priceRate: this.getPoolTokenRate({\n                                pool,\n                                token: token as RawPoolTokenWithRate,\n                                data,\n                                index: token.index,\n                            }),\n                            weight: data?.weights\n                                ? formatUnits(data.weights[token.index], 18)\n                                : (token as RawWeightedPoolToken).weight,\n                        };\n                    }),\n                totalShares: data?.totalSupply\n                    ? (formatUnits(data.totalSupply, 18) as HumanAmount)\n                    : pool.totalShares,\n                amp: data?.amp\n                    ? formatUnits(data.amp, 3).split('.')[0]\n                    : 'amp' in pool\n                    ? pool.amp\n                    : undefined,\n                swapFee: data?.swapFee\n                    ? (formatUnits(data.swapFee, 18) as HumanAmount)\n                    : pool.swapFee,\n            };\n        });\n    }\n\n    private getPoolDataQueryParams(data: GetPoolsResponse) {\n        const poolIds: Hex[] = [];\n        const totalSupplyTypes: TotalSupplyType[] = [];\n        const linearPoolIdxs: bigint[] = [];\n        const weightedPoolIdxs: bigint[] = [];\n        const ampPoolIdxs: bigint[] = [];\n        const scalingFactorPoolIdxs: bigint[] = [];\n        const swapFeeTypes: SwapFeeType[] = [];\n\n        const {\n            loadScalingFactorForPoolTypes,\n            loadScalingFactorForPoolIds,\n            loadWeightsForPoolTypes,\n            loadAmpForPoolTypes,\n            loadAmpForPoolIds,\n            loadWeightsForPoolIds,\n        } = this.getMergedFilterConfig(data);\n\n        for (let i = 0; i < data.pools.length; i++) {\n            const pool = data.pools[i];\n\n            poolIds.push(pool.id);\n\n            totalSupplyTypes.push(\n                poolHasVirtualSupply(pool.poolType)\n                    ? TotalSupplyType.VIRTUAL_SUPPLY\n                    : poolHasActualSupply(pool.poolType)\n                    ? TotalSupplyType.ACTUAL_SUPPLY\n                    : TotalSupplyType.TOTAL_SUPPLY,\n            );\n\n            if (poolIsLinearPool(pool.poolType)) {\n                linearPoolIdxs.push(BigInt(i));\n            }\n\n            if (\n                loadWeightsForPoolTypes.has(pool.poolType) ||\n                loadWeightsForPoolIds.has(pool.id)\n            ) {\n                weightedPoolIdxs.push(BigInt(i));\n            }\n\n            if (\n                loadAmpForPoolTypes.has(pool.poolType) ||\n                loadAmpForPoolIds.has(pool.id)\n            ) {\n                ampPoolIdxs.push(BigInt(i));\n            }\n\n            if (\n                loadScalingFactorForPoolIds.has(pool.id) ||\n                loadScalingFactorForPoolTypes.has(pool.poolType)\n            ) {\n                scalingFactorPoolIdxs.push(BigInt(i));\n            }\n\n            if (this.config.loadSwapFees) {\n                swapFeeTypes.push(\n                    poolHasPercentFee(pool.poolType)\n                        ? SwapFeeType.PERCENT_FEE\n                        : SwapFeeType.SWAP_FEE_PERCENTAGE,\n                );\n            }\n        }\n\n        return {\n            poolIds,\n            totalSupplyTypes,\n            linearPoolIdxs,\n            weightedPoolIdxs,\n            ampPoolIdxs,\n            scalingFactorPoolIdxs,\n            swapFeeTypes,\n        };\n    }\n\n    private getMergedFilterConfig({\n        poolsWithActiveWeightUpdates = [],\n        poolsWithActiveAmpUpdates = [],\n    }: {\n        poolsWithActiveWeightUpdates?: string[];\n        poolsWithActiveAmpUpdates?: string[];\n    }) {\n        const {\n            loadWeightsForPools,\n            loadScalingFactorForPools,\n            loadAmpForPools,\n        } = this.config;\n\n        const loadWeightsForPoolIds = new Set([\n            ...poolsWithActiveWeightUpdates,\n            ...(loadWeightsForPools.poolIds || []),\n        ]);\n        const loadAmpForPoolIds = new Set([\n            ...poolsWithActiveAmpUpdates,\n            ...(loadAmpForPools.poolIds || []),\n        ]);\n        const loadScalingFactorForPoolIds = new Set(\n            loadScalingFactorForPools.poolIds || [],\n        );\n        const loadWeightsForPoolTypes = new Set(\n            loadWeightsForPools.poolTypes || [],\n        );\n        const loadAmpForPoolTypes = new Set(loadAmpForPools.poolTypes || []);\n        const loadScalingFactorForPoolTypes = new Set(\n            loadScalingFactorForPools.poolTypes || [],\n        );\n\n        return {\n            loadWeightsForPoolIds,\n            loadAmpForPoolIds,\n            loadScalingFactorForPoolIds,\n            loadWeightsForPoolTypes,\n            loadAmpForPoolTypes,\n            loadScalingFactorForPoolTypes,\n        };\n    }\n\n    private getPoolTokenRate({\n        pool,\n        token,\n        data,\n        index,\n    }: {\n        pool: RawPool;\n        token: RawPoolTokenWithRate;\n        data?: OnChainPoolData;\n        index: number;\n    }): string {\n        if (\n            data?.wrappedTokenRate &&\n            'wrappedIndex' in pool &&\n            pool.wrappedIndex === index\n        ) {\n            return formatUnits(data.wrappedTokenRate, 18);\n        }\n\n        if (data?.scalingFactors) {\n            return formatUnits(data.scalingFactors[index], 18);\n        }\n\n        return token.priceRate;\n    }\n}\n","export const balancerQueriesAbi = [\n    {\n        inputs: [\n            {\n                internalType: 'contract IVault',\n                name: '_vault',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'enum IVault.SwapKind',\n                name: 'kind',\n                type: 'uint8',\n            },\n            {\n                components: [\n                    {\n                        internalType: 'bytes32',\n                        name: 'poolId',\n                        type: 'bytes32',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'assetInIndex',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'assetOutIndex',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'amount',\n                        type: 'uint256',\n                    },\n                    { internalType: 'bytes', name: 'userData', type: 'bytes' },\n                ],\n                internalType: 'struct IVault.BatchSwapStep[]',\n                name: 'swaps',\n                type: 'tuple[]',\n            },\n            {\n                internalType: 'contract IAsset[]',\n                name: 'assets',\n                type: 'address[]',\n            },\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'sender',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'fromInternalBalance',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'address payable',\n                        name: 'recipient',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'toInternalBalance',\n                        type: 'bool',\n                    },\n                ],\n                internalType: 'struct IVault.FundManagement',\n                name: 'funds',\n                type: 'tuple',\n            },\n        ],\n        name: 'queryBatchSwap',\n        outputs: [\n            { internalType: 'int256[]', name: 'assetDeltas', type: 'int256[]' },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            { internalType: 'bytes32', name: 'poolId', type: 'bytes32' },\n            { internalType: 'address', name: 'sender', type: 'address' },\n            { internalType: 'address', name: 'recipient', type: 'address' },\n            {\n                components: [\n                    {\n                        internalType: 'contract IAsset[]',\n                        name: 'assets',\n                        type: 'address[]',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'minAmountsOut',\n                        type: 'uint256[]',\n                    },\n                    { internalType: 'bytes', name: 'userData', type: 'bytes' },\n                    {\n                        internalType: 'bool',\n                        name: 'toInternalBalance',\n                        type: 'bool',\n                    },\n                ],\n                internalType: 'struct IVault.ExitPoolRequest',\n                name: 'request',\n                type: 'tuple',\n            },\n        ],\n        name: 'queryExit',\n        outputs: [\n            { internalType: 'uint256', name: 'bptIn', type: 'uint256' },\n            {\n                internalType: 'uint256[]',\n                name: 'amountsOut',\n                type: 'uint256[]',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            { internalType: 'bytes32', name: 'poolId', type: 'bytes32' },\n            { internalType: 'address', name: 'sender', type: 'address' },\n            { internalType: 'address', name: 'recipient', type: 'address' },\n            {\n                components: [\n                    {\n                        internalType: 'contract IAsset[]',\n                        name: 'assets',\n                        type: 'address[]',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'maxAmountsIn',\n                        type: 'uint256[]',\n                    },\n                    { internalType: 'bytes', name: 'userData', type: 'bytes' },\n                    {\n                        internalType: 'bool',\n                        name: 'fromInternalBalance',\n                        type: 'bool',\n                    },\n                ],\n                internalType: 'struct IVault.JoinPoolRequest',\n                name: 'request',\n                type: 'tuple',\n            },\n        ],\n        name: 'queryJoin',\n        outputs: [\n            { internalType: 'uint256', name: 'bptOut', type: 'uint256' },\n            { internalType: 'uint256[]', name: 'amountsIn', type: 'uint256[]' },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        internalType: 'bytes32',\n                        name: 'poolId',\n                        type: 'bytes32',\n                    },\n                    {\n                        internalType: 'enum IVault.SwapKind',\n                        name: 'kind',\n                        type: 'uint8',\n                    },\n                    {\n                        internalType: 'contract IAsset',\n                        name: 'assetIn',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'contract IAsset',\n                        name: 'assetOut',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'amount',\n                        type: 'uint256',\n                    },\n                    { internalType: 'bytes', name: 'userData', type: 'bytes' },\n                ],\n                internalType: 'struct IVault.SingleSwap',\n                name: 'singleSwap',\n                type: 'tuple',\n            },\n            {\n                components: [\n                    {\n                        internalType: 'address',\n                        name: 'sender',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'fromInternalBalance',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'address payable',\n                        name: 'recipient',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'toInternalBalance',\n                        type: 'bool',\n                    },\n                ],\n                internalType: 'struct IVault.FundManagement',\n                name: 'funds',\n                type: 'tuple',\n            },\n        ],\n        name: 'querySwap',\n        outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'vault',\n        outputs: [\n            { internalType: 'contract IVault', name: '', type: 'address' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n] as const;\n","export const sorQueriesAbi = [\n    {\n        inputs: [\n            {\n                internalType: 'contract IVault',\n                name: '_vault',\n                type: 'address',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'poolAddresses',\n                type: 'address[]',\n            },\n        ],\n        name: 'getAmpForPools',\n        outputs: [{ internalType: 'uint256[]', name: '', type: 'uint256[]' }],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'poolAddresses',\n                type: 'address[]',\n            },\n        ],\n        name: 'getNormalizedWeightsForPools',\n        outputs: [\n            { internalType: 'uint256[][]', name: '', type: 'uint256[][]' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            { internalType: 'bytes32[]', name: 'poolIds', type: 'bytes32[]' },\n            {\n                components: [\n                    {\n                        internalType: 'bool',\n                        name: 'loadTokenBalanceUpdatesAfterBlock',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'loadTotalSupply',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'loadSwapFees',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'loadLinearWrappedTokenRates',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'loadNormalizedWeights',\n                        type: 'bool',\n                    },\n                    {\n                        internalType: 'bool',\n                        name: 'loadScalingFactors',\n                        type: 'bool',\n                    },\n                    { internalType: 'bool', name: 'loadAmps', type: 'bool' },\n                    {\n                        internalType: 'uint256',\n                        name: 'blockNumber',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'enum TotalSupplyType[]',\n                        name: 'totalSupplyTypes',\n                        type: 'uint8[]',\n                    },\n                    {\n                        internalType: 'enum SwapFeeType[]',\n                        name: 'swapFeeTypes',\n                        type: 'uint8[]',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'linearPoolIdxs',\n                        type: 'uint256[]',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'weightedPoolIdxs',\n                        type: 'uint256[]',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'scalingFactorPoolIdxs',\n                        type: 'uint256[]',\n                    },\n                    {\n                        internalType: 'uint256[]',\n                        name: 'ampPoolIdxs',\n                        type: 'uint256[]',\n                    },\n                ],\n                internalType: 'struct SorPoolDataQueryConfig',\n                name: 'config',\n                type: 'tuple',\n            },\n        ],\n        name: 'getPoolData',\n        outputs: [\n            {\n                internalType: 'uint256[][]',\n                name: 'balances',\n                type: 'uint256[][]',\n            },\n            {\n                internalType: 'uint256[]',\n                name: 'totalSupplies',\n                type: 'uint256[]',\n            },\n            { internalType: 'uint256[]', name: 'swapFees', type: 'uint256[]' },\n            {\n                internalType: 'uint256[]',\n                name: 'linearWrappedTokenRates',\n                type: 'uint256[]',\n            },\n            {\n                internalType: 'uint256[][]',\n                name: 'weights',\n                type: 'uint256[][]',\n            },\n            {\n                internalType: 'uint256[][]',\n                name: 'scalingFactors',\n                type: 'uint256[][]',\n            },\n            { internalType: 'uint256[]', name: 'amps', type: 'uint256[]' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            { internalType: 'bytes32[]', name: 'poolIds', type: 'bytes32[]' },\n            { internalType: 'uint256', name: 'blockNumber', type: 'uint256' },\n        ],\n        name: 'getPoolTokenBalancesWithUpdatesAfterBlock',\n        outputs: [\n            { internalType: 'uint256[][]', name: '', type: 'uint256[][]' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'poolAddresses',\n                type: 'address[]',\n            },\n        ],\n        name: 'getScalingFactorsForPools',\n        outputs: [\n            { internalType: 'uint256[][]', name: '', type: 'uint256[][]' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'poolAddresses',\n                type: 'address[]',\n            },\n            {\n                internalType: 'enum SwapFeeType[]',\n                name: 'swapFeeTypes',\n                type: 'uint8[]',\n            },\n        ],\n        name: 'getSwapFeePercentageForPools',\n        outputs: [{ internalType: 'uint256[]', name: '', type: 'uint256[]' }],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'poolAddresses',\n                type: 'address[]',\n            },\n            {\n                internalType: 'enum TotalSupplyType[]',\n                name: 'totalSupplyTypes',\n                type: 'uint8[]',\n            },\n        ],\n        name: 'getTotalSupplyForPools',\n        outputs: [{ internalType: 'uint256[]', name: '', type: 'uint256[]' }],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'poolAddresses',\n                type: 'address[]',\n            },\n        ],\n        name: 'getWrappedTokenRateForLinearPools',\n        outputs: [{ internalType: 'uint256[]', name: '', type: 'uint256[]' }],\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        inputs: [],\n        name: 'vault',\n        outputs: [\n            { internalType: 'contract IVault', name: '', type: 'address' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n] as const;\n","import { Address } from 'viem';\nexport class Token {\n    public readonly chainId: number;\n    public readonly address: Address;\n    public readonly decimals: number;\n    public readonly symbol?: string;\n    public readonly name?: string;\n    public readonly wrapped: string;\n\n    public constructor(\n        chainId: number,\n        address: Address,\n        decimals: number,\n        symbol?: string,\n        name?: string,\n        wrapped?: string,\n    ) {\n        this.chainId = chainId;\n        // Addresses are always lowercased for speed\n        this.address = address.toLowerCase() as Address;\n        this.decimals = decimals;\n        this.symbol = symbol;\n        this.name = name;\n\n        wrapped\n            ? (this.wrapped = wrapped.toLowerCase())\n            : (this.wrapped = address.toLowerCase());\n    }\n\n    public isEqual(token: Token) {\n        return this.chainId === token.chainId && this.address === token.address;\n    }\n\n    public isUnderlyingEqual(token: Token) {\n        return this.chainId === token.chainId && this.wrapped === token.wrapped;\n    }\n}\n","import { Address } from 'viem';\nimport { Token } from '../entities/token';\n\nexport const ZERO_ADDRESS: Address =\n    '0x0000000000000000000000000000000000000000';\nexport const NATIVE_ADDRESS: Address =\n    '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';\n\nexport const MAX_UINT112 = 5192296858534827628530496329220095n;\nexport const PREMINTED_STABLE_BPT = 2596148429267413814265248164610048n; // 2**111\n\nexport const DECIMAL_SCALES = {\n    0: 1n,\n    1: 10n,\n    2: 100n,\n    3: 1000n,\n    4: 10000n,\n    5: 100000n,\n    6: 1000000n,\n    7: 10000000n,\n    8: 100000000n,\n    9: 1000000000n,\n    10: 10000000000n,\n    11: 100000000000n,\n    12: 1000000000000n,\n    13: 10000000000000n,\n    14: 100000000000000n,\n    15: 1000000000000000n,\n    16: 10000000000000000n,\n    17: 100000000000000000n,\n    18: 1000000000000000000n,\n};\n\nexport const SECONDS_PER_YEAR = 31536000n;\n\nexport enum ChainId {\n    MAINNET = 1,\n    GOERLI = 5,\n    OPTIMISM = 10,\n    BSC = 56,\n    GNOSIS_CHAIN = 100,\n    POLYGON = 137,\n    ZKSYNC_TESTNET = 280,\n    ZKSYNC = 324,\n    ZKEVM = 1101,\n    ARBITRUM_ONE = 42161,\n    AVALANCHE = 43114,\n    BASE_GOERLI = 84531,\n}\n\nexport const SUBGRAPH_URLS = {\n    [ChainId.MAINNET]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-v2',\n    [ChainId.GOERLI]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-goerli-v2',\n    [ChainId.OPTIMISM]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-optimism-v2',\n    [ChainId.GNOSIS_CHAIN]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-gnosis-chain-v2',\n    [ChainId.POLYGON]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-polygon-v2',\n    [ChainId.ZKSYNC_TESTNET]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-zktestnet-v2',\n    [ChainId.ZKSYNC]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-zksync-v2',\n    [ChainId.ZKEVM]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-zkevm-v2',\n    [ChainId.ARBITRUM_ONE]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-arbitrum-v2',\n    [ChainId.AVALANCHE]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-avalanche-v2',\n    [ChainId.BASE_GOERLI]:\n        'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-base-goerli-v2',\n};\n\nexport const STELLATE_URLS = {\n    [ChainId.MAINNET]: 'https://balancer-v2.stellate.balancer.fi',\n    [ChainId.GOERLI]: 'https://balancer-goerli-v2.stellate.balancer.fi',\n    [ChainId.GNOSIS_CHAIN]:\n        'https://balancer-gnosis-chain-v2.stellate.balancer.fi',\n    [ChainId.POLYGON]: 'https://balancer-polygon-v2.stellate.balancer.fi',\n    [ChainId.ARBITRUM_ONE]: 'https://balancer-arbitrum-v2.stellate.balancer.fi',\n};\n\nexport const BALANCER_QUERIES = '0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5';\nexport const BALANCER_SOR_QUERIES_ADDRESS =\n    '0x1814a3b3e4362caf4eb54cd85b82d39bd7b34e41';\n\nexport const NATIVE_ASSETS = {\n    [ChainId.MAINNET]: new Token(\n        ChainId.MAINNET,\n        NATIVE_ADDRESS,\n        18,\n        'ETH',\n        'Ether',\n        '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n    ),\n    [ChainId.GOERLI]: new Token(\n        ChainId.GOERLI,\n        NATIVE_ADDRESS,\n        18,\n        'ETH',\n        'Ether',\n        '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6',\n    ),\n    [ChainId.GNOSIS_CHAIN]: new Token(\n        ChainId.GNOSIS_CHAIN,\n        NATIVE_ADDRESS,\n        18,\n        'xDAI',\n        'xDAI',\n        '0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d',\n    ),\n    [ChainId.POLYGON]: new Token(\n        ChainId.POLYGON,\n        NATIVE_ADDRESS,\n        18,\n        'MATIC',\n        'Matic',\n        '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',\n    ),\n    [ChainId.ARBITRUM_ONE]: new Token(\n        ChainId.ARBITRUM_ONE,\n        NATIVE_ADDRESS,\n        18,\n        'ETH',\n        'Ether',\n        '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',\n    ),\n};\n\nexport const ETH = NATIVE_ASSETS[ChainId.MAINNET];\n\nexport const DEFAULT_FUND_MANAGMENT = {\n    sender: ZERO_ADDRESS,\n    recipient: ZERO_ADDRESS,\n    fromInternalBalance: false,\n    toInternalBalance: false,\n};\n\nexport const DEFAULT_USERDATA = '0x';\n","import { BigintIsh, Token, BasePool, BasePoolFactory } from './entities';\nimport { PoolDataEnricher, PoolDataProvider } from './data/types';\nimport { PathGraphTraversalConfig } from './pathGraph/pathGraphTypes';\nimport { Address, Hex } from 'viem';\n\nexport { Address, Hex };\n\nexport type SwapInputRawAmount = BigintIsh;\n\nexport enum PoolType {\n    Weighted = 'Weighted',\n    ComposableStable = 'ComposableStable',\n    MetaStable = 'MetaStable',\n    AaveLinear = 'AaveLinear',\n}\n\nexport enum SwapKind {\n    GivenIn = 0,\n    GivenOut = 1,\n}\n\nexport interface SwapOptions {\n    block?: bigint;\n    slippage?: bigint;\n    funds?: FundManagement;\n    deadline?: bigint;\n    graphTraversalConfig?: Partial<PathGraphTraversalConfig>;\n}\n\nexport interface FundManagement {\n    sender: string;\n    fromInternalBalance: boolean;\n    recipient: boolean;\n    toInternalBalance: boolean;\n}\n\nexport type SorConfig = {\n    chainId: number;\n    rpcUrl: string;\n    poolDataProviders?: PoolDataProvider | PoolDataProvider[];\n    poolDataEnrichers?: PoolDataEnricher | PoolDataEnricher[];\n    customPoolFactories?: BasePoolFactory[];\n};\n\nexport interface PoolTokenPair {\n    id: string;\n    pool: BasePool;\n    tokenIn: Token;\n    tokenOut: Token;\n}\n\nexport interface SingleSwap {\n    poolId: Hex;\n    kind: SwapKind;\n    assetIn: Address;\n    assetOut: Address;\n    amount: bigint;\n    userData: Hex;\n}\n\nexport interface BatchSwapStep {\n    poolId: Hex;\n    assetInIndex: bigint;\n    assetOutIndex: bigint;\n    amount: bigint;\n    userData: Hex;\n}\n\nexport type HumanAmount = `${number}`;\n","import { BasePool } from './pools/';\nimport { Token, TokenAmount } from './';\nimport { SwapKind } from '../types';\n\nexport class Path {\n    public readonly pools: BasePool[];\n    public readonly tokens: Token[];\n\n    public constructor(tokens: Token[], pools: BasePool[]) {\n        if (pools.length === 0 || tokens.length < 2) {\n            throw new Error(\n                'Invalid path: must contain at least 1 pool and 2 tokens.',\n            );\n        } else if (tokens.length !== pools.length + 1) {\n            throw new Error(\n                'Invalid path: tokens length must equal pools length + 1',\n            );\n        }\n\n        this.pools = pools;\n        this.tokens = tokens;\n    }\n}\n\nexport class PathWithAmount extends Path {\n    public readonly swapAmount: TokenAmount;\n    public readonly swapKind: SwapKind;\n    public readonly outputAmount: TokenAmount;\n    public readonly inputAmount: TokenAmount;\n    private readonly mutateBalances: boolean;\n    private readonly printPath: any = [];\n\n    public constructor(\n        tokens: Token[],\n        pools: BasePool[],\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ) {\n        super(tokens, pools);\n        this.swapAmount = swapAmount;\n        this.mutateBalances = Boolean(mutateBalances);\n\n        //call to super ensures this array access is safe\n        if (tokens[0].isUnderlyingEqual(swapAmount.token)) {\n            this.swapKind = SwapKind.GivenIn;\n        } else {\n            this.swapKind = SwapKind.GivenOut;\n        }\n\n        try {\n            if (this.swapKind === SwapKind.GivenIn) {\n                const amounts: TokenAmount[] = new Array(this.tokens.length);\n                amounts[0] = this.swapAmount;\n                for (let i = 0; i < this.pools.length; i++) {\n                    const pool = this.pools[i];\n                    const outputAmount = pool.swapGivenIn(\n                        this.tokens[i],\n                        this.tokens[i + 1],\n                        amounts[i],\n                        this.mutateBalances,\n                    );\n                    amounts[i + 1] = outputAmount;\n                    this.printPath.push({\n                        pool: pool.id,\n                        input: `${amounts[i].amount.toString()} ${\n                            this.tokens[i].symbol\n                        }`,\n                        output: `${outputAmount.amount.toString()} ${\n                            this.tokens[i + 1].symbol\n                        }`,\n                    });\n                }\n                this.outputAmount = amounts[amounts.length - 1];\n                this.inputAmount = this.swapAmount;\n            } else {\n                const amounts: TokenAmount[] = new Array(this.tokens.length);\n                amounts[amounts.length - 1] = this.swapAmount;\n                for (let i = this.pools.length; i >= 1; i--) {\n                    const pool = this.pools[i - 1];\n                    const inputAmount = pool.swapGivenOut(\n                        this.tokens[i - 1],\n                        this.tokens[i],\n                        amounts[i],\n                        this.mutateBalances,\n                    );\n                    amounts[i - 1] = inputAmount;\n                    this.printPath.push({\n                        pool: pool.id,\n                        input: `${inputAmount.amount.toString()} ${\n                            this.tokens[i - 1].symbol\n                        }`,\n                        output: `${amounts[i].amount.toString()} ${\n                            this.tokens[i].symbol\n                        }`,\n                    });\n                }\n                this.printPath = this.printPath.reverse();\n                this.inputAmount = amounts[0];\n                this.outputAmount = this.swapAmount;\n            }\n        } catch {\n            throw new Error(\n                'Invalid path, swap amount exceeds maximum for pool',\n            );\n        }\n    }\n\n    public print(): void {\n        console.table(this.printPath);\n    }\n}\n","import { Token } from './token';\nimport _Decimal from 'decimal.js-light';\nimport { parseUnits } from 'viem';\nimport { DECIMAL_SCALES, WAD } from '../utils';\n\nexport type BigintIsh = bigint | string | number;\n\nexport class TokenAmount {\n    public readonly token: Token;\n    public readonly scalar: bigint;\n    public readonly decimalScale: bigint;\n    public amount: bigint;\n    public scale18: bigint;\n\n    public static fromRawAmount(token: Token, rawAmount: BigintIsh) {\n        return new TokenAmount(token, rawAmount);\n    }\n\n    public static fromHumanAmount(token: Token, humanAmount: `${number}`) {\n        const rawAmount = parseUnits(humanAmount, token.decimals);\n        return new TokenAmount(token, rawAmount);\n    }\n\n    public static fromScale18Amount(\n        token: Token,\n        scale18Amount: BigintIsh,\n        divUp?: boolean,\n    ) {\n        const scalar = DECIMAL_SCALES[18 - token.decimals];\n        const rawAmount = divUp\n            ? 1n + (BigInt(scale18Amount) - 1n) / scalar\n            : BigInt(scale18Amount) / scalar;\n        return new TokenAmount(token, rawAmount);\n    }\n\n    protected constructor(token: Token, amount: BigintIsh) {\n        this.decimalScale = DECIMAL_SCALES[token.decimals];\n        this.token = token;\n        this.amount = BigInt(amount);\n        this.scalar = DECIMAL_SCALES[18 - token.decimals];\n        this.scale18 = this.amount * this.scalar;\n    }\n\n    public add(other: TokenAmount): TokenAmount {\n        return new TokenAmount(this.token, this.amount + other.amount);\n    }\n\n    public sub(other: TokenAmount): TokenAmount {\n        return new TokenAmount(this.token, this.amount - other.amount);\n    }\n\n    public mulUpFixed(other: bigint): TokenAmount {\n        const product = this.amount * other;\n        const multiplied = (product - 1n) / WAD + 1n;\n        return new TokenAmount(this.token, multiplied);\n    }\n\n    public mulDownFixed(other: bigint): TokenAmount {\n        const multiplied = (this.amount * other) / WAD;\n        return new TokenAmount(this.token, multiplied);\n    }\n\n    public divUpFixed(other: bigint): TokenAmount {\n        const divided = (this.amount * WAD + other - 1n) / other;\n        return new TokenAmount(this.token, divided);\n    }\n\n    public divDownFixed(other: bigint): TokenAmount {\n        const divided = (this.amount * WAD) / other;\n        return new TokenAmount(this.token, divided);\n    }\n\n    public toSignificant(significantDigits: number = 6): string {\n        return new _Decimal(this.amount.toString())\n            .div(new _Decimal(this.decimalScale.toString()))\n            .toDecimalPlaces(significantDigits)\n            .toString();\n    }\n}\n","import { PathWithAmount } from './path';\nimport { TokenAmount } from './tokenAmount';\nimport { SingleSwap, SwapKind, BatchSwapStep } from '../types';\nimport {\n    abs,\n    BALANCER_QUERIES,\n    DEFAULT_USERDATA,\n    DEFAULT_FUND_MANAGMENT,\n    ZERO_ADDRESS,\n    NATIVE_ADDRESS,\n} from '../utils';\nimport {\n    Address,\n    createPublicClient,\n    encodeFunctionData,\n    getContract,\n    http,\n} from 'viem';\nimport { balancerQueriesAbi } from '../abi/';\n\n// A Swap can be a single or multiple paths\nexport class Swap {\n    public constructor({\n        paths,\n        swapKind,\n    }: { paths: PathWithAmount[]; swapKind: SwapKind }) {\n        if (paths.length === 0)\n            throw new Error('Invalid swap: must contain at least 1 path.');\n        // Recalculate paths while mutating pool balances\n        this.paths = paths.map(\n            (path) =>\n                new PathWithAmount(\n                    path.tokens,\n                    path.pools,\n                    path.swapAmount,\n                    true,\n                ),\n        );\n        this.chainId = paths[0].tokens[0].chainId;\n        this.swapKind = swapKind;\n        this.isBatchSwap = paths.length > 1 || paths[0].pools.length > 1;\n        this.assets = [\n            ...new Set(paths.flatMap((p) => p.tokens).map((t) => t.address)),\n        ];\n        let swaps: BatchSwapStep[] | SingleSwap;\n        if (this.isBatchSwap) {\n            swaps = [] as BatchSwapStep[];\n            if (this.swapKind === SwapKind.GivenIn) {\n                this.paths.map((p) => {\n                    p.pools.map((pool, i) => {\n                        (swaps as BatchSwapStep[]).push({\n                            poolId: pool.id,\n                            assetInIndex: BigInt(\n                                this.assets.indexOf(p.tokens[i].address),\n                            ),\n                            assetOutIndex: BigInt(\n                                this.assets.indexOf(p.tokens[i + 1].address),\n                            ),\n                            amount: i === 0 ? p.inputAmount.amount : 0n,\n                            userData: DEFAULT_USERDATA,\n                        });\n                    });\n                });\n            } else {\n                this.paths.map((p) => {\n                    // Vault expects given out swaps to be in reverse order\n                    const reversedPools = [...p.pools].reverse();\n                    const reversedTokens = [...p.tokens].reverse();\n                    reversedPools.map((pool, i) => {\n                        (swaps as BatchSwapStep[]).push({\n                            poolId: pool.id,\n                            assetInIndex: BigInt(\n                                this.assets.indexOf(\n                                    reversedTokens[i + 1].address,\n                                ),\n                            ),\n                            assetOutIndex: BigInt(\n                                this.assets.indexOf(reversedTokens[i].address),\n                            ),\n                            amount: i === 0 ? p.outputAmount.amount : 0n,\n                            userData: DEFAULT_USERDATA,\n                        });\n                    });\n                });\n            }\n        } else {\n            const path = this.paths[0];\n            const pool = path.pools[0];\n            const assetIn = this.convertNativeAddressToZero(\n                path.tokens[0].address,\n            );\n            const assetOut = this.convertNativeAddressToZero(\n                path.tokens[1].address,\n            );\n            swaps = {\n                poolId: pool.id,\n                kind: this.swapKind,\n                assetIn,\n                assetOut,\n                amount: path.swapAmount.amount,\n                userData: DEFAULT_USERDATA,\n            } as SingleSwap;\n        }\n\n        this.assets = this.assets.map((a) => {\n            return this.convertNativeAddressToZero(a);\n        });\n\n        this.swaps = swaps;\n    }\n\n    public readonly chainId: number;\n    public readonly isBatchSwap: boolean;\n    public readonly paths: PathWithAmount[];\n    public readonly assets: Address[];\n    public readonly swapKind: SwapKind;\n    public swaps: BatchSwapStep[] | SingleSwap;\n\n    public get quote(): TokenAmount {\n        return this.swapKind === SwapKind.GivenIn\n            ? this.outputAmount\n            : this.inputAmount;\n    }\n\n    public get inputAmount(): TokenAmount {\n        if (\n            !this.paths.every((p) =>\n                p.inputAmount.token.isEqual(this.paths[0].inputAmount.token),\n            )\n        ) {\n            throw new Error(\n                'Input amount can only be calculated if all paths have the same input token',\n            );\n        }\n        const amounts = this.paths.map((path) => path.inputAmount);\n        return amounts.reduce((a, b) => a.add(b));\n    }\n\n    public get outputAmount(): TokenAmount {\n        if (\n            !this.paths.every((p) =>\n                p.outputAmount.token.isEqual(this.paths[0].outputAmount.token),\n            )\n        ) {\n            throw new Error(\n                'Output amount can only be calculated if all paths have the same output token',\n            );\n        }\n        const amounts = this.paths.map((path) => path.outputAmount);\n        return amounts.reduce((a, b) => a.add(b));\n    }\n\n    // rpcUrl is optional, but recommended to prevent rate limiting\n    public async query(rpcUrl?: string, block?: bigint): Promise<TokenAmount> {\n        const publicClient = createPublicClient({\n            transport: http(rpcUrl),\n        });\n\n        const queriesContract = getContract({\n            address: BALANCER_QUERIES,\n            abi: balancerQueriesAbi,\n            publicClient,\n        });\n\n        let amount: TokenAmount;\n        if (this.isBatchSwap) {\n            const { result } = await queriesContract.simulate.queryBatchSwap(\n                [\n                    this.swapKind,\n                    this.swaps as BatchSwapStep[],\n                    this.assets,\n                    DEFAULT_FUND_MANAGMENT,\n                ],\n                {\n                    blockNumber: block,\n                },\n            );\n\n            amount =\n                this.swapKind === SwapKind.GivenIn\n                    ? TokenAmount.fromRawAmount(\n                          this.outputAmount.token,\n                          abs(\n                              result[\n                                  this.assets.indexOf(\n                                      this.convertNativeAddressToZero(\n                                          this.outputAmount.token.address,\n                                      ),\n                                  )\n                              ],\n                          ),\n                      )\n                    : TokenAmount.fromRawAmount(\n                          this.inputAmount.token,\n                          abs(\n                              result[\n                                  this.assets.indexOf(\n                                      this.convertNativeAddressToZero(\n                                          this.inputAmount.token.address,\n                                      ),\n                                  )\n                              ],\n                          ),\n                      );\n        } else {\n            const { result } = await queriesContract.simulate.querySwap(\n                [this.swaps as SingleSwap, DEFAULT_FUND_MANAGMENT],\n                { blockNumber: block },\n            );\n\n            amount =\n                this.swapKind === SwapKind.GivenIn\n                    ? TokenAmount.fromRawAmount(this.outputAmount.token, result)\n                    : TokenAmount.fromRawAmount(this.inputAmount.token, result);\n        }\n\n        return amount;\n    }\n\n    private convertNativeAddressToZero(address: Address): Address {\n        return address === NATIVE_ADDRESS ? ZERO_ADDRESS : address;\n    }\n\n    public queryCallData(): string {\n        let callData: string;\n        if (this.isBatchSwap) {\n            callData = encodeFunctionData({\n                abi: balancerQueriesAbi,\n                functionName: 'queryBatchSwap',\n                args: [\n                    this.swapKind,\n                    this.swaps as BatchSwapStep[],\n                    this.assets,\n                    DEFAULT_FUND_MANAGMENT,\n                ],\n            });\n        } else {\n            callData = encodeFunctionData({\n                abi: balancerQueriesAbi,\n                functionName: 'querySwap',\n                args: [this.swaps as SingleSwap, DEFAULT_FUND_MANAGMENT],\n            });\n        }\n        return callData;\n    }\n\n    // public get executionPrice(): Price {}\n    // public get priceImpact(): Percent {}\n}\n","import { BigintIsh, Token, TokenAmount } from '../entities';\nimport { SwapKind } from '../types';\n\nexport function checkInputs(\n    tokenIn: Token,\n    tokenOut: Token,\n    swapKind: SwapKind,\n    swapAmount: BigintIsh | TokenAmount,\n): TokenAmount {\n    if (!(swapAmount instanceof TokenAmount)) {\n        swapAmount = TokenAmount.fromRawAmount(\n            swapKind === SwapKind.GivenIn ? tokenIn : tokenOut,\n            swapAmount,\n        );\n    }\n    if (\n        tokenIn.chainId !== tokenOut.chainId ||\n        tokenIn.chainId !== swapAmount.token.chainId\n    ) {\n        throw new Error('ChainId mismatch for inputs');\n    }\n\n    if (\n        (swapKind === SwapKind.GivenIn && !tokenIn.isEqual(swapAmount.token)) ||\n        (swapKind === SwapKind.GivenOut && !tokenOut.isEqual(swapAmount.token))\n    ) {\n        throw new Error('Swap amount token does not match input token');\n    }\n\n    return swapAmount;\n}\n","export const WAD = 1000000000000000000n;\nexport const TWO_WAD = 2000000000000000000n;\nexport const FOUR_WAD = 4000000000000000000n;\n\nexport const abs = (n: bigint): bigint => (n < 0n ? -n : n);\n\nconst _require = (b: boolean, message: string) => {\n    if (!b) throw new Error(message);\n};\n\nexport class MathSol {\n    static max(a: bigint, b: bigint): bigint {\n        return a >= b ? a : b;\n    }\n\n    static min(a: bigint, b: bigint): bigint {\n        return a < b ? a : b;\n    }\n\n    static MAX_POW_RELATIVE_ERROR = 10000n;\n\n    static mulDownFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        return product / WAD;\n    }\n\n    static mulUpFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n\n        if (product === 0n) {\n            return 0n;\n        } else {\n            return (product - 1n) / WAD + 1n;\n        }\n    }\n\n    static divDownFixed(a: bigint, b: bigint): bigint {\n        if (a === 0n) {\n            return 0n;\n        } else {\n            const aInflated = a * WAD;\n            return aInflated / b;\n        }\n    }\n\n    static divUpFixed(a: bigint, b: bigint): bigint {\n        if (a === 0n) {\n            return 0n;\n        } else {\n            const aInflated = a * WAD;\n            return (aInflated - 1n) / b + 1n;\n        }\n    }\n\n    static divUp(a: bigint, b: bigint): bigint {\n        if (a === 0n) {\n            return 0n;\n        } else {\n            return 1n + (a - 1n) / b;\n        }\n    }\n\n    // version = poolTypeVersion\n    static powUpFixed(x: bigint, y: bigint, version?: number): bigint {\n        if (y === WAD && version !== 1) {\n            return x;\n        } else if (y === TWO_WAD && version !== 1) {\n            return this.mulUpFixed(x, x);\n        } else if (y === FOUR_WAD && version !== 1) {\n            const square = this.mulUpFixed(x, x);\n            return this.mulUpFixed(square, square);\n        } else {\n            const raw = LogExpMath.pow(x, y);\n            const maxError =\n                this.mulUpFixed(raw, this.MAX_POW_RELATIVE_ERROR) + 1n;\n            return raw + maxError;\n        }\n    }\n\n    // version = poolTypeVersion\n    static powDownFixed(x: bigint, y: bigint, version?: number): bigint {\n        if (y === WAD && version !== 1) {\n            return x;\n        } else if (y === TWO_WAD && version !== 1) {\n            return this.mulUpFixed(x, x);\n        } else if (y === FOUR_WAD && version !== 1) {\n            const square = this.mulUpFixed(x, x);\n            return this.mulUpFixed(square, square);\n        } else {\n            const raw = LogExpMath.pow(x, y);\n            const maxError =\n                this.mulUpFixed(raw, this.MAX_POW_RELATIVE_ERROR) + 1n;\n            if (raw < maxError) {\n                return 0n;\n            } else {\n                return raw - maxError;\n            }\n        }\n    }\n\n    static complementFixed(x: bigint): bigint {\n        return x < WAD ? WAD - x : 0n;\n    }\n}\n\nclass LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    static ONE_18 = BigInt('1000000000000000000');\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    static ONE_20 = BigInt('100000000000000000000');\n    static ONE_36 = BigInt('1000000000000000000000000000000000000');\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    static MAX_NATURAL_EXPONENT = BigInt('130000000000000000000');\n    static MIN_NATURAL_EXPONENT = BigInt('-41000000000000000000');\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    static LN_36_LOWER_BOUND: bigint =\n        BigInt(LogExpMath.ONE_18) - BigInt('100000000000000000');\n    static LN_36_UPPER_BOUND: bigint =\n        BigInt(LogExpMath.ONE_18) + BigInt('100000000000000000');\n\n    // static MILD_EXPONENT_BOUND: bigint = BigInt(2) ** BigInt(254) / LogExpMath.ONE_20;\n    // Precomputed value of the above expression\n    static MILD_EXPONENT_BOUND: bigint = BigInt(\n        '289480223093290488558927462521719769633174961664101410098',\n    );\n\n    // 18 decimal constants\n    static x0 = BigInt('128000000000000000000'); // 2ˆ7\n    static a0 = BigInt(\n        '38877084059945950922200000000000000000000000000000000000',\n    ); // eˆ(x0) (no decimals)\n    static x1 = BigInt('64000000000000000000'); // 2ˆ6\n    static a1 = BigInt('6235149080811616882910000000'); // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    static x2 = BigInt('3200000000000000000000'); // 2ˆ5\n    static a2 = BigInt('7896296018268069516100000000000000'); // eˆ(x2)\n    static x3 = BigInt('1600000000000000000000'); // 2ˆ4\n    static a3 = BigInt('888611052050787263676000000'); // eˆ(x3)\n    static x4 = BigInt('800000000000000000000'); // 2ˆ3\n    static a4 = BigInt('298095798704172827474000'); // eˆ(x4)\n    static x5 = BigInt('400000000000000000000'); // 2ˆ2\n    static a5 = BigInt('5459815003314423907810'); // eˆ(x5)\n    static x6 = BigInt('200000000000000000000'); // 2ˆ1\n    static a6 = BigInt('738905609893065022723'); // eˆ(x6)\n    static x7 = BigInt('100000000000000000000'); // 2ˆ0\n    static a7 = BigInt('271828182845904523536'); // eˆ(x7)\n    static x8 = BigInt('50000000000000000000'); // 2ˆ-1\n    static a8 = BigInt('164872127070012814685'); // eˆ(x8)\n    static x9 = BigInt('25000000000000000000'); // 2ˆ-2\n    static a9 = BigInt('128402541668774148407'); // eˆ(x9)\n    static x10 = BigInt('12500000000000000000'); // 2ˆ-3\n    static a10 = BigInt('113314845306682631683'); // eˆ(x10)\n    static x11 = BigInt('6250000000000000000'); // 2ˆ-4\n    static a11 = BigInt('106449445891785942956'); // eˆ(x11)\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    static pow(x: bigint, y: bigint): bigint {\n        if (y === 0n) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return this.ONE_18;\n        }\n\n        if (x === 0n) {\n            return 0n;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(\n            x <\n                BigInt(\n                    '57896044618658097711785492504343953926634992332820282019728792003956564819968',\n                ),\n            'Errors.X_OUT_OF_BOUNDS',\n        );\n        const x_int256 = x;\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < this.MILD_EXPONENT_BOUND, 'Errors.Y_OUT_OF_BOUNDS');\n        const y_int256 = y;\n\n        let logx_times_y;\n        if (\n            this.LN_36_LOWER_BOUND < x_int256 &&\n            x_int256 < this.LN_36_UPPER_BOUND\n        ) {\n            const ln_36_x = this._ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y =\n                (ln_36_x / this.ONE_18) * y_int256 +\n                ((ln_36_x % this.ONE_18) * y_int256) / this.ONE_18;\n        } else {\n            logx_times_y = this._ln(x_int256) * y_int256;\n        }\n        logx_times_y /= this.ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            this.MIN_NATURAL_EXPONENT <= logx_times_y &&\n                logx_times_y <= this.MAX_NATURAL_EXPONENT,\n            'Errors.PRODUCT_OUT_OF_BOUNDS',\n        );\n\n        // return uint256(exp(logx_times_y));\n        return this.exp(logx_times_y);\n    }\n\n    static exp(x: bigint): bigint {\n        _require(\n            x >= this.MIN_NATURAL_EXPONENT && x <= this.MAX_NATURAL_EXPONENT,\n            'Errors.INVALID_EXPONENT',\n        );\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return (this.ONE_18 * this.ONE_18) / this.exp(BigInt(-1) * x);\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        let firstAN;\n        if (x >= this.x0) {\n            x -= this.x0;\n            firstAN = this.a0;\n        } else if (x >= this.x1) {\n            x -= this.x1;\n            firstAN = this.a1;\n        } else {\n            firstAN = BigInt(1); // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= BigInt(100);\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        let product = this.ONE_20;\n\n        if (x >= this.x2) {\n            x -= this.x2;\n            product = (product * this.a2) / this.ONE_20;\n        }\n        if (x >= this.x3) {\n            x -= this.x3;\n            product = (product * this.a3) / this.ONE_20;\n        }\n        if (x >= this.x4) {\n            x -= this.x4;\n            product = (product * this.a4) / this.ONE_20;\n        }\n        if (x >= this.x5) {\n            x -= this.x5;\n            product = (product * this.a5) / this.ONE_20;\n        }\n        if (x >= this.x6) {\n            x -= this.x6;\n            product = (product * this.a6) / this.ONE_20;\n        }\n        if (x >= this.x7) {\n            x -= this.x7;\n            product = (product * this.a7) / this.ONE_20;\n        }\n        if (x >= this.x8) {\n            x -= this.x8;\n            product = (product * this.a8) / this.ONE_20;\n        }\n        if (x >= this.x9) {\n            x -= this.x9;\n            product = (product * this.a9) / this.ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        let seriesSum = this.ONE_20; // The initial one in the sum, with 20 decimal places.\n        let term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by this.ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = (term * x) / this.ONE_20 / BigInt(2);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(3);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(4);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(5);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(6);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(7);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(8);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(9);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(10);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(11);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(12);\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by this.ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / this.ONE_20) * firstAN) / BigInt(100);\n    }\n\n    static _ln_36(x: bigint): bigint {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= this.ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        const z = ((x - this.ONE_36) * this.ONE_36) / (x + this.ONE_36);\n        const z_squared = (z * z) / this.ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(3);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(5);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(7);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(9);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(11);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(13);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(15);\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * BigInt(2);\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    static _ln(a: bigint): bigint {\n        if (a < this.ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by this.ONE_18.\n            return BigInt(-1) * this._ln((this.ONE_18 * this.ONE_18) / a);\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // this.ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        let sum = 0n;\n        if (a >= this.a0 * this.ONE_18) {\n            a /= this.a0; // Integer, not fixed point division\n            sum += this.x0;\n        }\n\n        if (a >= this.a1 * this.ONE_18) {\n            a /= this.a1; // Integer, not fixed point division\n            sum += this.x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= BigInt(100);\n        a *= BigInt(100);\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= this.a2) {\n            a = (a * this.ONE_20) / this.a2;\n            sum += this.x2;\n        }\n\n        if (a >= this.a3) {\n            a = (a * this.ONE_20) / this.a3;\n            sum += this.x3;\n        }\n\n        if (a >= this.a4) {\n            a = (a * this.ONE_20) / this.a4;\n            sum += this.x4;\n        }\n\n        if (a >= this.a5) {\n            a = (a * this.ONE_20) / this.a5;\n            sum += this.x5;\n        }\n\n        if (a >= this.a6) {\n            a = (a * this.ONE_20) / this.a6;\n            sum += this.x6;\n        }\n\n        if (a >= this.a7) {\n            a = (a * this.ONE_20) / this.a7;\n            sum += this.x7;\n        }\n\n        if (a >= this.a8) {\n            a = (a * this.ONE_20) / this.a8;\n            sum += this.x8;\n        }\n\n        if (a >= this.a9) {\n            a = (a * this.ONE_20) / this.a9;\n            sum += this.x9;\n        }\n\n        if (a >= this.a10) {\n            a = (a * this.ONE_20) / this.a10;\n            sum += this.x10;\n        }\n\n        if (a >= this.a11) {\n            a = (a * this.ONE_20) / this.a11;\n            sum += this.x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        const z = ((a - this.ONE_20) * this.ONE_20) / (a + this.ONE_20);\n        const z_squared = (z * z) / this.ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(3);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(5);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(7);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(9);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(11);\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= BigInt(2);\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / BigInt(100);\n    }\n}\n","/**\n * Extracts a pool's address from its poolId\n * @param poolId - a bytes32 string of the pool's ID\n * @returns the pool's address\n */\nexport const getPoolAddress = (poolId: string): string => {\n    if (poolId.length !== 66) throw new Error('Invalid poolId length');\n    return poolId.slice(0, 42).toLowerCase();\n};\n\nexport function poolIsLinearPool(poolType: string) {\n    return poolType.includes('Linear');\n}\n\nexport function poolHasVirtualSupply(poolType: string) {\n    return poolType === 'PhantomStable' || poolIsLinearPool(poolType);\n}\n\nexport function poolHasActualSupply(poolType: string) {\n    return poolType === 'ComposableStable';\n}\n\nexport function poolHasPercentFee(poolType: string) {\n    return poolType === 'Element';\n}\n","import { default as retry } from 'async-retry';\n\nexport async function fetchWithRetry<T>(\n    fetch: () => Promise<T>,\n    config = { retries: 1 },\n): Promise<T | null> {\n    let response: T | null = null;\n    await retry(\n        async () => {\n            response = await fetch();\n            return response;\n        },\n        {\n            retries: config.retries,\n        },\n    );\n\n    return response;\n}\n","import {\n    GetPoolsResponse,\n    PoolDataProvider,\n    ProviderSwapOptions,\n    RawPool,\n} from '../types';\nimport { fetchWithRetry } from '../../utils/fetch';\nimport { SUBGRAPH_URLS } from '../../utils';\n\nBigInt.prototype['toJSON'] = function () {\n    return this.toString();\n};\n\nconst PAGE_SIZE = 1000;\nconst SECS_IN_HOUR = 3600n;\n\ninterface PoolUpdate {\n    poolId: {\n        id: string;\n    };\n}\n\ninterface SubgraphPoolProviderConfig {\n    retries: number;\n    timeout: number;\n    //pool type and id filters\n    poolTypeIn?: string[];\n    poolTypeNotIn?: string[];\n    poolIdIn?: string[];\n    poolIdNotIn?: string[];\n    // whether to include a query for active gradualWeightUpdates\n    loadActiveWeightUpdates?: boolean;\n    // whether to include a query for active ampUpdates\n    loadActiveAmpUpdates?: boolean;\n    // whether to apply pool filtering on the gql query or in code. Depending on the subgraph\n    // endpoint, it is sometimes more efficient to query the full data set and filter post.\n    addFilterToPoolQuery?: boolean;\n    // if you need to fetch additional pool fields, you can provide them here.\n    // this field is typed as a string to allow for the expansion of nested field values\n    gqlAdditionalPoolQueryFields?: string;\n}\n\nexport class SubgraphPoolProvider implements PoolDataProvider {\n    private readonly url: string;\n    private readonly config: SubgraphPoolProviderConfig;\n\n    constructor(\n        chainId: number,\n        subgraphUrl?: string,\n        config?: Partial<SubgraphPoolProviderConfig>,\n    ) {\n        // if subgraphUrl isnt provided, use the default for the chainId\n        const defaultSubgraphUrl = SUBGRAPH_URLS[chainId];\n        this.url = subgraphUrl ?? defaultSubgraphUrl;\n\n        const hasFilterConfig =\n            config &&\n            (config.poolIdNotIn ||\n                config.poolIdIn ||\n                config.poolTypeIn ||\n                config.poolTypeNotIn);\n\n        this.config = {\n            retries: 2,\n            timeout: 30000,\n            loadActiveAmpUpdates: true,\n            // we assume a public subgraph is being used, so default to false\n            addFilterToPoolQuery: false,\n            // by default, we exclude pool types with weight updates.\n            // if any filtering config is provided, this exclusion is removed.\n            poolTypeNotIn: !hasFilterConfig\n                ? ['Investment', 'LiquidityBootstrapping']\n                : undefined,\n            ...config,\n        };\n    }\n\n    public async getPools(\n        options: ProviderSwapOptions,\n    ): Promise<GetPoolsResponse> {\n        const response = await fetchWithRetry<GetPoolsResponse>(() =>\n            this.fetchDataFromSubgraph(options),\n        );\n\n        return {\n            ...response,\n            pools: response?.pools || [],\n            syncedToBlockNumber: response?.syncedToBlockNumber || 0n,\n        };\n    }\n\n    private async fetchDataFromSubgraph(\n        options: ProviderSwapOptions,\n    ): Promise<GetPoolsResponse> {\n        let ampUpdates: PoolUpdate[] = [];\n        let syncedToBlockNumber: bigint = 0n;\n        let lastId: string = '';\n        let pools: RawPool[] = [];\n        let poolsPage: RawPool[] = [];\n        const nowMinusOneHour = options.timestamp - SECS_IN_HOUR;\n        const nowPlusOneHour = options.timestamp + SECS_IN_HOUR;\n\n        do {\n            const query = this.getPoolsQuery(lastId === '');\n            const variables = {\n                pageSize: PAGE_SIZE,\n                where: {\n                    id_gt: lastId || undefined,\n                    ...(this.config.addFilterToPoolQuery\n                        ? {\n                              totalShares_gt: 0.000000000001,\n                              swapEnabled: true,\n                              poolType_in: this.config.poolTypeIn,\n                              poolType_not_in: this.config.poolTypeNotIn,\n                              id_in: this.config.poolIdIn,\n                              id_not_in: this.config.poolIdNotIn,\n                          }\n                        : {}),\n                },\n                ...(options?.block\n                    ? {\n                          block: {\n                              number: Number(options.block),\n                          },\n                      }\n                    : {}),\n                ampUpdatesWhere: {\n                    endTimestamp_gte: nowMinusOneHour,\n                    startTimestamp_lte: nowPlusOneHour,\n                },\n                weightedUpdatesWhere: {\n                    endTimestamp_gte: nowMinusOneHour,\n                    startTimestamp_lte: nowPlusOneHour,\n                },\n            };\n\n            const response = await fetch(this.url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    query,\n                    variables,\n                }),\n            });\n\n            const poolsResult = await response.json();\n\n            poolsPage = poolsResult.data.pools;\n            pools = pools.concat(poolsPage);\n\n            if (lastId === '') {\n                ampUpdates = poolsResult.ampUpdates || [];\n            }\n\n            if (poolsResult._meta) {\n                syncedToBlockNumber = BigInt(poolsResult._meta.block.number);\n            }\n\n            lastId = pools[pools.length - 1]!.id;\n        } while (poolsPage.length === PAGE_SIZE);\n\n        // we apply the filter after querying if not set in the config\n        if (!this.config.addFilterToPoolQuery) {\n            pools = pools.filter((pool) => this.poolMatchesFilter(pool));\n        }\n\n        return {\n            pools,\n            poolsWithActiveAmpUpdates: ampUpdates.map(\n                (update) => update.poolId.id,\n            ),\n            syncedToBlockNumber,\n        };\n    }\n\n    private getPoolsQuery(isFirstQuery: boolean) {\n        const {\n            loadActiveAmpUpdates,\n            loadActiveWeightUpdates,\n            gqlAdditionalPoolQueryFields,\n        } = this.config;\n\n        const blockNumberFragment = `\n            _meta {\n                block {\n                    number\n                }\n            }\n        `;\n\n        const ampUpdatesFragment = `\n            ampUpdates(where: $ampUpdatesWhere) {\n                poolId {\n                    id\n                }\n            }\n        `;\n\n        const weightUpdatesFragment = `\n            gradualWeightUpdates(where: $weightedUpdatesWhere) {\n                poolId {\n                    id\n                }\n            }\n        `;\n\n        return `\n            query poolsQuery(\n                $pageSize: Int!\n                $where: Pool_filter\n                $block: Block_height\n                $ampUpdatesWhere: AmpUpdate_filter\n                $weightedUpdatesWhere: GradualWeightUpdate_filter\n            ) {\n                pools(first: $pageSize, where: $where, block: $block) {\n                    id\n                    address\n                    poolType\n                    poolTypeVersion\n                    tokens {\n                        address\n                        balance\n                        weight\n                        priceRate\n                        decimals\n                        name\n                        index\n                        symbol\n                    }\n                    tokensList\n                    swapEnabled\n                    swapFee\n                    amp\n                    totalLiquidity\n                    totalShares\n                    mainIndex\n                    wrappedIndex\n                    lowerTarget\n                    upperTarget\n                    ${gqlAdditionalPoolQueryFields || ''}\n                }\n                ${isFirstQuery ? blockNumberFragment : ''}\n                ${\n                    isFirstQuery && loadActiveAmpUpdates\n                        ? ampUpdatesFragment\n                        : ''\n                }\n                ${\n                    isFirstQuery && loadActiveWeightUpdates\n                        ? weightUpdatesFragment\n                        : ''\n                }\n            }\n        `;\n    }\n\n    private poolMatchesFilter(pool: RawPool) {\n        if (\n            !pool.swapEnabled ||\n            pool.totalShares === '0.000000000001' ||\n            pool.totalShares === '0'\n        ) {\n            return false;\n        }\n\n        if (\n            this.config.poolTypeIn &&\n            !this.config.poolTypeIn.includes(pool.poolType)\n        ) {\n            return false;\n        }\n\n        if (this.config.poolTypeNotIn?.includes(pool.poolType)) {\n            return false;\n        }\n\n        if (this.config.poolIdIn && !this.config.poolIdIn.includes(pool.id)) {\n            return false;\n        }\n\n        if (this.config.poolIdNotIn?.includes(pool.id)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n","import pino from 'pino';\n\nconst LOG_LEVEL = process.env.LOG_LEVEL || 'info';\n\nexport const logger = pino({\n    formatters: {\n        level(level) {\n            return { level };\n        },\n    },\n    base: undefined,\n    level: LOG_LEVEL,\n});\n","import { BasePool, Path, Token, TokenAmount } from '../entities';\nimport { PathGraphEdgeData, PathGraphTraversalConfig } from './pathGraphTypes';\nimport { PoolType, SwapKind } from '../types';\n\nconst DEFAULT_MAX_PATHS_PER_TOKEN_PAIR = 2;\n\nexport class PathGraph {\n    private nodes: Map<string, { isPhantomBpt: boolean }>;\n    private edges: Map<string, Map<string, PathGraphEdgeData[]>>;\n    private poolAddressMap: Map<string, BasePool>;\n    private maxPathsPerTokenPair = DEFAULT_MAX_PATHS_PER_TOKEN_PAIR;\n\n    constructor() {\n        this.nodes = new Map();\n        this.edges = new Map();\n        this.poolAddressMap = new Map();\n    }\n\n    // We build a directed graph for all pools.\n    // Nodes are tokens and edges are triads: [pool.id, tokenIn, tokenOut].\n    // The current criterion for including a pool path into this graph is the following:\n    // (a) We include every path that includes a phantom BPT.\n    // (b) For any token pair x -> y, we include only the most liquid ${maxPathsPerTokenPair}\n    // pool pairs (default 2).\n    public buildGraph({\n        pools,\n        maxPathsPerTokenPair = DEFAULT_MAX_PATHS_PER_TOKEN_PAIR,\n    }: {\n        pools: BasePool[];\n        maxPathsPerTokenPair?: number;\n    }) {\n        this.poolAddressMap = new Map();\n        this.nodes = new Map();\n        this.edges = new Map();\n        this.maxPathsPerTokenPair = maxPathsPerTokenPair;\n\n        this.buildPoolAddressMap(pools);\n\n        this.addAllTokensAsGraphNodes(pools);\n\n        this.addTokenPairsAsGraphEdges({ pools, maxPathsPerTokenPair });\n    }\n\n    // Since the path combinations here can get quite large, we use configurable parameters\n    // to enforce upper limits across several dimensions, defined in the pathConfig.\n    // (a) maxDepth - the max depth of the traversal (length of token path), defaults to 7.\n    // (b) maxNonBoostedPathDepth - the max depth for any path that does not contain a phantom bpt.\n    // (c) maxNonBoostedHopTokensInBoostedPath - The max number of non boosted hop tokens\n    // allowed in a boosted path.\n    // (d) approxPathsToReturn - search for up to this many paths. Since all paths for a single traversal\n    // are added, its possible that the amount returned is larger than this number.\n    // (e) poolIdsToInclude - Only include paths with these poolIds (optional)\n\n    // Additionally, we impose the following requirements for a path to be considered valid\n    // (a) It does not visit the same token twice\n    // (b) It does not use the same pool twice\n    public getCandidatePaths({\n        tokenIn,\n        tokenOut,\n        graphTraversalConfig,\n    }: {\n        tokenIn: Token;\n        tokenOut: Token;\n        graphTraversalConfig?: Partial<PathGraphTraversalConfig>;\n    }): Path[] {\n        // apply defaults, allowing caller override whatever they'd like\n        const config: PathGraphTraversalConfig = {\n            maxDepth: 6,\n            maxNonBoostedPathDepth: 3,\n            maxNonBoostedHopTokensInBoostedPath: 2,\n            approxPathsToReturn: 5,\n            ...graphTraversalConfig,\n        };\n\n        const tokenPaths = this.findAllValidTokenPaths({\n            token: tokenIn.wrapped,\n            tokenIn: tokenIn.wrapped,\n            tokenOut: tokenOut.wrapped,\n            config,\n            tokenPath: [tokenIn.wrapped],\n        }).sort((a, b) => (a.length < b.length ? -1 : 1));\n\n        const paths: PathGraphEdgeData[][] = [];\n        const selectedPathIds: string[] = [];\n\n        // the tokenPairIndex refers to the nth most liquid path for a token\n        // pair x -> y. maxPathsPerTokenPair is provided as a config on graph init\n        for (let idx = 0; idx < this.maxPathsPerTokenPair; idx++) {\n            for (let i = 0; i < tokenPaths.length; i++) {\n                const path = this.expandTokenPath({\n                    tokenPath: tokenPaths[i],\n                    tokenPairIndex: idx,\n                });\n\n                if (\n                    this.isValidPath({\n                        path,\n                        seenPoolAddresses: [],\n                        selectedPathIds,\n                        config,\n                    })\n                ) {\n                    selectedPathIds.push(this.getIdForPath(path));\n                    paths.push(path);\n                }\n            }\n\n            // we've found enough paths, there's no need to go deeper into the token pair options.\n            if (paths.length >= config.approxPathsToReturn) {\n                break;\n            }\n        }\n\n        return this.sortAndFilterPaths(paths).map((path) => {\n            const pathTokens: Token[] = [\n                ...path.map((segment) => segment.tokenOut),\n            ];\n            pathTokens.unshift(tokenIn);\n            pathTokens[pathTokens.length - 1] = tokenOut;\n\n            return {\n                tokens: pathTokens,\n                pools: path.map((segment) => segment.pool),\n            };\n        });\n    }\n\n    private sortAndFilterPaths(\n        paths: PathGraphEdgeData[][],\n    ): PathGraphEdgeData[][] {\n        const pathsWithLimits = paths\n            .map((path) => {\n                const limit = this.getLimitAmountSwapForPath(\n                    path,\n                    SwapKind.GivenIn,\n                );\n                return { path, limit };\n            })\n            .sort((a, b) => (a.limit < b.limit ? 1 : -1));\n\n        const filtered: PathGraphEdgeData[][] = [];\n\n        // Remove any paths with duplicate pools. since the paths are now sorted by limit,\n        // selecting the first path will always be the optimal.\n        for (const { path } of pathsWithLimits) {\n            let seenPools: string[] = [];\n            let isValid = true;\n\n            for (const segment of path) {\n                if (seenPools.includes(segment.pool.id)) {\n                    isValid = false;\n                    break;\n                }\n            }\n\n            if (isValid) {\n                filtered.push(path);\n                seenPools = [\n                    ...seenPools,\n                    ...path.map((segment) => segment.pool.id),\n                ];\n            }\n        }\n\n        return filtered;\n    }\n\n    private buildPoolAddressMap(pools: BasePool[]) {\n        for (const pool of pools) {\n            this.poolAddressMap.set(pool.address, pool);\n        }\n    }\n\n    private addAllTokensAsGraphNodes(pools: BasePool[]) {\n        for (const pool of pools) {\n            for (const tokenAmount of pool.tokens) {\n                const token = tokenAmount.token;\n\n                if (!this.nodes.has(token.wrapped)) {\n                    this.addNode(token);\n                }\n            }\n        }\n    }\n\n    private addTokenPairsAsGraphEdges({\n        pools,\n        maxPathsPerTokenPair,\n    }: {\n        pools: BasePool[];\n        maxPathsPerTokenPair: number;\n    }) {\n        for (const pool of pools) {\n            for (let i = 0; i < pool.tokens.length - 1; i++) {\n                for (let j = i + 1; j < pool.tokens.length; j++) {\n                    const tokenI = pool.tokens[i].token;\n                    const tokenJ = pool.tokens[j].token;\n\n                    this.addEdge({\n                        edgeProps: {\n                            pool,\n                            tokenIn: tokenI,\n                            tokenOut: tokenJ,\n                            normalizedLiquidity: pool.getNormalizedLiquidity(\n                                tokenI,\n                                tokenJ,\n                            ),\n                        },\n                        maxPathsPerTokenPair,\n                    });\n\n                    this.addEdge({\n                        edgeProps: {\n                            pool,\n                            tokenIn: tokenJ,\n                            tokenOut: tokenI,\n                            normalizedLiquidity: pool.getNormalizedLiquidity(\n                                tokenJ,\n                                tokenI,\n                            ),\n                        },\n                        maxPathsPerTokenPair,\n                    });\n                }\n            }\n        }\n    }\n\n    private addNode(token: Token): void {\n        this.nodes.set(token.wrapped, {\n            isPhantomBpt: !!this.poolAddressMap[token.wrapped],\n        });\n\n        if (!this.edges.has(token.wrapped)) {\n            this.edges.set(token.wrapped, new Map());\n        }\n    }\n\n    /**\n     * Returns the vertices connected to a given vertex\n     */\n    public getConnectedVertices(tokenAddress: string): string[] {\n        const result: string[] = [];\n        const edges = this.edges.get(tokenAddress) || [];\n\n        for (const [otherToken] of edges) {\n            result.push(otherToken);\n        }\n\n        return result;\n    }\n\n    /**\n     * Adds a directed edge from a source vertex to a destination\n     */\n    private addEdge({\n        edgeProps,\n        maxPathsPerTokenPair,\n    }: {\n        edgeProps: PathGraphEdgeData;\n        maxPathsPerTokenPair: number;\n    }): void {\n        const tokenInVertex = this.nodes.get(edgeProps.tokenIn.wrapped);\n        const tokenOutVertex = this.nodes.get(edgeProps.tokenOut.wrapped);\n        const tokenInNode = this.edges.get(edgeProps.tokenIn.wrapped);\n\n        if (!tokenInVertex || !tokenOutVertex || !tokenInNode) {\n            throw new Error('Attempting to add invalid edge');\n        }\n\n        const hasPhantomBpt =\n            tokenInVertex.isPhantomBpt || tokenOutVertex.isPhantomBpt;\n        const existingEdges = tokenInNode.get(edgeProps.tokenOut.wrapped) || [];\n\n        //TODO: ideally we don't call sort every time, this isn't performant\n        const sorted = [...existingEdges, edgeProps].sort((a, b) =>\n            a.normalizedLiquidity > b.normalizedLiquidity ? -1 : 1,\n        );\n\n        tokenInNode.set(\n            edgeProps.tokenOut.wrapped,\n            sorted.length > maxPathsPerTokenPair && !hasPhantomBpt\n                ? sorted.slice(0, 2)\n                : sorted,\n        );\n    }\n\n    public findAllValidTokenPaths(args: {\n        token: string;\n        tokenIn: string;\n        tokenOut: string;\n        tokenPath: string[];\n        config: PathGraphTraversalConfig;\n    }): string[][] {\n        const tokenPaths: string[][] = [];\n\n        this.traverseBfs({\n            ...args,\n            callback: (tokenPath) => {\n                tokenPaths.push(tokenPath);\n            },\n        });\n\n        return tokenPaths;\n    }\n\n    public expandTokenPath({\n        tokenPath,\n        tokenPairIndex,\n    }: {\n        tokenPath: string[];\n        tokenPairIndex: number;\n    }) {\n        const segments: PathGraphEdgeData[] = [];\n\n        for (let i = 0; i < tokenPath.length - 1; i++) {\n            const edge = this.edges.get(tokenPath[i])?.get(tokenPath[i + 1]);\n\n            if (!edge || edge.length === 0) {\n                throw new Error(\n                    `Missing edge for pair ${tokenPath[i]} -> ${\n                        tokenPath[i + 1]\n                    }`,\n                );\n            }\n\n            segments.push(edge[tokenPairIndex] || edge[0]);\n        }\n\n        return segments;\n    }\n\n    private traverseBfs({\n        token,\n        tokenIn,\n        tokenOut,\n        tokenPath,\n        callback,\n        config,\n    }: {\n        token: string;\n        tokenIn: string;\n        tokenOut: string;\n        tokenPath: string[];\n        callback: (tokenPath: string[]) => void;\n        config: PathGraphTraversalConfig;\n    }): void {\n        const neighbors = this.getConnectedVertices(token);\n\n        for (const neighbor of neighbors) {\n            const validTokenPath = this.isValidTokenPath({\n                tokenPath: [...tokenPath, neighbor],\n                tokenIn,\n                tokenOut,\n                config,\n            });\n\n            if (validTokenPath && neighbor === tokenOut) {\n                callback([...tokenPath, neighbor]);\n            } else if (validTokenPath && !tokenPath.includes(neighbor)) {\n                this.traverseBfs({\n                    tokenPath: [...tokenPath, neighbor],\n                    token: neighbor,\n                    tokenIn,\n                    tokenOut,\n                    callback,\n                    config,\n                });\n            }\n        }\n    }\n\n    private isValidTokenPath({\n        tokenPath,\n        config,\n        tokenIn,\n        tokenOut,\n    }: {\n        tokenPath: string[];\n        config: PathGraphTraversalConfig;\n        tokenIn: string;\n        tokenOut: string;\n    }) {\n        const isCompletePath = tokenPath[tokenPath.length - 1] === tokenOut;\n        const hopTokens = tokenPath.filter(\n            (token) => token !== tokenIn && token !== tokenOut,\n        );\n        const numStandardHopTokens = hopTokens.filter(\n            (token) => !this.poolAddressMap.has(token),\n        ).length;\n        const isBoostedPath =\n            tokenPath.filter((token) => this.poolAddressMap.has(token)).length >\n            0;\n\n        if (tokenPath.length > config.maxDepth) {\n            return false;\n        }\n\n        if (\n            isBoostedPath &&\n            numStandardHopTokens > config.maxNonBoostedHopTokensInBoostedPath\n        ) {\n            return false;\n        }\n\n        // if the path length is greater than maxNonBoostedPathDepth, then this path\n        // will only be valid if its a boosted path, so it must honor maxNonBoostedHopTokensInBoostedPath\n        if (\n            tokenPath.length > config.maxNonBoostedPathDepth &&\n            numStandardHopTokens > config.maxNonBoostedHopTokensInBoostedPath\n        ) {\n            return false;\n        }\n\n        if (\n            isCompletePath &&\n            !isBoostedPath &&\n            tokenPath.length > config.maxNonBoostedPathDepth\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private isValidPath({\n        path,\n        seenPoolAddresses,\n        selectedPathIds,\n        config,\n    }: {\n        path: PathGraphEdgeData[];\n        seenPoolAddresses: string[];\n        selectedPathIds: string[];\n        config: PathGraphTraversalConfig;\n    }) {\n        const poolIdsInPath = path.map((segment) => segment.pool.id);\n        const uniquePools = [...new Set(poolIdsInPath)];\n\n        if (config.poolIdsToInclude) {\n            for (const poolId of poolIdsInPath) {\n                if (!config.poolIdsToInclude.includes(poolId)) {\n                    //path includes a pool that is not allowed for this traversal\n                    return false;\n                }\n            }\n        }\n\n        //dont include any path that hops through the same pool twice\n        if (uniquePools.length !== poolIdsInPath.length) {\n            return false;\n        }\n\n        for (const segment of path) {\n            if (seenPoolAddresses.includes(segment.pool.address)) {\n                //this path contains a pool that has already been used\n                return false;\n            }\n        }\n\n        //this is a duplicate path\n        if (selectedPathIds.includes(this.getIdForPath(path))) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private getIdForPath(path: PathGraphEdgeData[]): string {\n        let id = '';\n\n        for (const segment of path) {\n            if (id.length > 0) {\n                id += '_';\n            }\n\n            id += `${segment.pool.id}-${segment.tokenIn}-${segment.tokenOut}`;\n        }\n\n        return id;\n    }\n\n    private filterVolatilePools(poolAddresses: string[]): string[] {\n        const filtered: string[] = [];\n\n        for (const poolAddress of poolAddresses) {\n            if (\n                this.poolAddressMap.get(poolAddress)?.poolType ===\n                PoolType.Weighted\n            ) {\n                filtered.push(poolAddress);\n            }\n        }\n\n        return filtered;\n    }\n\n    private getLimitAmountSwapForPath(\n        path: PathGraphEdgeData[],\n        swapKind: SwapKind,\n    ): bigint {\n        let limit = path[path.length - 1].pool.getLimitAmountSwap(\n            path[path.length - 1].tokenIn,\n            path[path.length - 1].tokenOut,\n            swapKind,\n        );\n\n        for (let i = path.length - 2; i >= 0; i--) {\n            const poolLimitExactIn = path[i].pool.getLimitAmountSwap(\n                path[i].tokenIn,\n                path[i].tokenOut,\n                SwapKind.GivenIn,\n            );\n            const poolLimitExactOut = path[i].pool.getLimitAmountSwap(\n                path[i].tokenIn,\n                path[i].tokenOut,\n                SwapKind.GivenOut,\n            );\n\n            if (poolLimitExactOut <= limit) {\n                limit = poolLimitExactIn;\n            } else {\n                const pulledLimit = path[i].pool.swapGivenOut(\n                    path[i].tokenIn,\n                    path[i].tokenOut,\n                    TokenAmount.fromRawAmount(path[i].tokenOut, limit),\n                ).amount;\n\n                limit =\n                    pulledLimit > poolLimitExactIn\n                        ? poolLimitExactIn\n                        : pulledLimit;\n            }\n        }\n\n        return limit;\n    }\n}\n","import { SwapKind } from './types';\nimport { logger } from './utils/logger';\nimport { WAD } from './utils/math';\nimport { BasePool, Path, PathWithAmount, Token, TokenAmount } from './entities';\nimport { PathGraph } from './pathGraph/pathGraph';\nimport { PathGraphTraversalConfig } from './pathGraph/pathGraphTypes';\n\nexport class Router {\n    private readonly pathGraph: PathGraph;\n\n    constructor() {\n        this.pathGraph = new PathGraph();\n    }\n\n    public getCandidatePaths(\n        tokenIn: Token,\n        tokenOut: Token,\n        pools: BasePool[],\n        graphTraversalConfig?: Partial<PathGraphTraversalConfig>,\n    ): Path[] {\n        this.pathGraph.buildGraph({ pools });\n\n        const candidatePaths = this.pathGraph.getCandidatePaths({\n            tokenIn,\n            tokenOut,\n            graphTraversalConfig,\n        });\n\n        return candidatePaths;\n    }\n\n    public getBestPaths(\n        paths: Path[],\n        swapKind: SwapKind,\n        swapAmount: TokenAmount,\n    ): PathWithAmount[] | null {\n        if (paths.length === 0) {\n            throw new Error('No potential swap paths provided');\n        }\n\n        const quotePaths: PathWithAmount[] = [];\n\n        // Check if PathWithAmount is valid (each hop pool swap limit)\n        paths.forEach((path) => {\n            try {\n                quotePaths.push(\n                    new PathWithAmount(path.tokens, path.pools, swapAmount),\n                );\n            } catch {\n                logger.trace('Invalid path:');\n                logger.trace(\n                    path.tokens.map((token) => token.symbol).join(' -> '),\n                );\n                logger.trace(path.pools.map((pool) => pool.id).join(' -> '));\n                return;\n            }\n        });\n\n        if (quotePaths.length === 0) {\n            logger.info('No valid paths found');\n            return null;\n        }\n\n        let valueArr: { item: PathWithAmount; value: number }[];\n\n        if (swapKind === SwapKind.GivenIn) {\n            (valueArr = quotePaths.map((item) => {\n                return {\n                    item,\n                    value: Number(item.outputAmount.amount),\n                };\n            })),\n                valueArr.sort((a, b) => b.value - a.value);\n        } else {\n            (valueArr = quotePaths.map((item) => {\n                return {\n                    item,\n                    value: Number(item.inputAmount.amount),\n                };\n            })),\n                valueArr.sort((a, b) => a.value - b.value);\n        }\n\n        const orderedQuotePaths = valueArr.map((item) => item.item);\n\n        // If there is only one path, return it\n        if (orderedQuotePaths.length === 1) {\n            return orderedQuotePaths;\n        }\n\n        // Split swapAmount in half, making sure not to lose dust\n        const swapAmount50up = swapAmount.mulDownFixed(WAD / 2n);\n        const swapAmount50down = swapAmount.sub(swapAmount50up);\n\n        const path50up = new PathWithAmount(\n            orderedQuotePaths[0].tokens,\n            orderedQuotePaths[0].pools,\n            swapAmount50up,\n        );\n        const path50down = new PathWithAmount(\n            orderedQuotePaths[1].tokens,\n            orderedQuotePaths[1].pools,\n            swapAmount50down,\n        );\n\n        if (swapKind === SwapKind.GivenIn) {\n            if (\n                orderedQuotePaths[0].outputAmount.amount >\n                path50up.outputAmount.amount + path50down.outputAmount.amount\n            ) {\n                return orderedQuotePaths.slice(0, 1);\n            } else {\n                return [path50up, path50down];\n            }\n        } else {\n            if (\n                orderedQuotePaths[0].inputAmount.amount <\n                path50up.inputAmount.amount + path50down.inputAmount.amount\n            ) {\n                return orderedQuotePaths.slice(0, 1);\n            } else {\n                return [path50up, path50down];\n            }\n        }\n    }\n}\n","import { BasePool, BasePoolFactory } from '../';\nimport { WeightedPool } from './';\nimport { RawPool, RawWeightedPool } from '../../../data/types';\n\nexport class WeightedPoolFactory implements BasePoolFactory {\n    public isPoolForFactory(pool: RawPool): boolean {\n        return pool.poolType === 'Weighted';\n    }\n\n    public create(chainId: number, pool: RawPool): BasePool {\n        return WeightedPool.fromRawPool(chainId, pool as RawWeightedPool);\n    }\n}\n","import { Hex, parseEther } from 'viem';\nimport { PoolType, SwapKind } from '../../../types';\nimport { Token, TokenAmount, BigintIsh } from '../../';\nimport { BasePool } from '../';\nimport { MathSol, WAD, getPoolAddress } from '../../../utils';\nimport { _calcOutGivenIn, _calcInGivenOut } from './weightedMath';\nimport { RawWeightedPool } from '../../../data/types';\n\nclass WeightedPoolToken extends TokenAmount {\n    public readonly weight: bigint;\n    public readonly index: number;\n\n    public constructor(\n        token: Token,\n        amount: BigintIsh,\n        weight: BigintIsh,\n        index: number,\n    ) {\n        super(token, amount);\n        this.weight = BigInt(weight);\n        this.index = index;\n    }\n\n    public increase(amount: bigint): TokenAmount {\n        this.amount = this.amount + amount;\n        this.scale18 = this.amount * this.scalar;\n        return this;\n    }\n\n    public decrease(amount: bigint): TokenAmount {\n        this.amount = this.amount - amount;\n        this.scale18 = this.amount * this.scalar;\n        return this;\n    }\n}\n\nexport class WeightedPool implements BasePool {\n    public readonly chainId: number;\n    public readonly id: Hex;\n    public readonly address: string;\n    public readonly poolType: PoolType = PoolType.Weighted;\n    public readonly poolTypeVersion: number;\n    public readonly swapFee: bigint;\n    public readonly tokens: WeightedPoolToken[];\n\n    private readonly tokenMap: Map<string, WeightedPoolToken>;\n    private readonly MAX_IN_RATIO = 300000000000000000n; // 0.3\n    private readonly MAX_OUT_RATIO = 300000000000000000n; // 0.3\n\n    static fromRawPool(chainId: number, pool: RawWeightedPool): WeightedPool {\n        const poolTokens: WeightedPoolToken[] = [];\n\n        for (const t of pool.tokens) {\n            if (!t.weight) {\n                throw new Error('Weighted pool token does not have a weight');\n            }\n\n            const token = new Token(\n                chainId,\n                t.address,\n                t.decimals,\n                t.symbol,\n                t.name,\n            );\n            const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);\n\n            poolTokens.push(\n                new WeightedPoolToken(\n                    token,\n                    tokenAmount.amount,\n                    parseEther(t.weight),\n                    t.index,\n                ),\n            );\n        }\n\n        return new WeightedPool(\n            pool.id,\n            pool.poolTypeVersion,\n            parseEther(pool.swapFee),\n            poolTokens,\n        );\n    }\n\n    constructor(\n        id: Hex,\n        poolTypeVersion: number,\n        swapFee: bigint,\n        tokens: WeightedPoolToken[],\n    ) {\n        this.chainId = tokens[0].token.chainId;\n        this.id = id;\n        this.poolTypeVersion = poolTypeVersion;\n        this.address = getPoolAddress(id);\n        this.swapFee = swapFee;\n        this.tokens = tokens;\n        this.tokenMap = new Map(\n            tokens.map((token) => [token.token.address, token]),\n        );\n    }\n\n    public getNormalizedLiquidity(tokenIn: Token, tokenOut: Token): bigint {\n        const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);\n\n        return (tIn.amount * tOut.weight) / (tIn.weight + tOut.weight);\n    }\n\n    public getLimitAmountSwap(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapKind: SwapKind,\n    ): bigint {\n        const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);\n\n        if (swapKind === SwapKind.GivenIn) {\n            return (tIn.amount * this.MAX_IN_RATIO) / WAD;\n        } else {\n            return (tOut.amount * this.MAX_OUT_RATIO) / WAD;\n        }\n    }\n\n    public swapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);\n\n        if (\n            swapAmount.amount >\n            this.getLimitAmountSwap(tokenIn, tokenOut, SwapKind.GivenIn)\n        ) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        const amountWithFee = this.subtractSwapFeeAmount(swapAmount);\n\n        const tokenOutScale18 = _calcOutGivenIn(\n            tIn.scale18,\n            tIn.weight,\n            tOut.scale18,\n            tOut.weight,\n            amountWithFee.scale18,\n            this.poolTypeVersion,\n        );\n\n        const tokenOutAmount = TokenAmount.fromScale18Amount(\n            tokenOut,\n            tokenOutScale18,\n        );\n\n        if (mutateBalances) {\n            tIn.increase(swapAmount.amount);\n            tOut.decrease(tokenOutAmount.amount);\n        }\n\n        return tokenOutAmount;\n    }\n\n    public swapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);\n\n        if (\n            swapAmount.amount >\n            this.getLimitAmountSwap(tokenIn, tokenOut, SwapKind.GivenOut)\n        ) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        const tokenInScale18 = _calcInGivenOut(\n            tIn.scale18,\n            tIn.weight,\n            tOut.scale18,\n            tOut.weight,\n            swapAmount.scale18,\n            this.poolTypeVersion,\n        );\n\n        const tokenInAmount = this.addSwapFeeAmount(\n            TokenAmount.fromScale18Amount(tokenIn, tokenInScale18, true),\n        );\n\n        if (mutateBalances) {\n            tIn.increase(tokenInAmount.amount);\n            tOut.decrease(swapAmount.amount);\n        }\n\n        return tokenInAmount;\n    }\n\n    public subtractSwapFeeAmount(amount: TokenAmount): TokenAmount {\n        const feeAmount = amount.mulUpFixed(this.swapFee);\n        return amount.sub(feeAmount);\n    }\n\n    public addSwapFeeAmount(amount: TokenAmount): TokenAmount {\n        return amount.divUpFixed(MathSol.complementFixed(this.swapFee));\n    }\n\n    private getRequiredTokenPair(\n        tokenIn: Token,\n        tokenOut: Token,\n    ): { tIn: WeightedPoolToken; tOut: WeightedPoolToken } {\n        const tIn = this.tokenMap.get(tokenIn.wrapped);\n        const tOut = this.tokenMap.get(tokenOut.wrapped);\n\n        if (!tIn || !tOut) {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        return { tIn, tOut };\n    }\n}\n","import { MathSol, WAD } from '../../../utils/math';\n\nexport function _calcOutGivenIn(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountIn: bigint,\n    version?: number,\n): bigint {\n    const denominator = balanceIn + amountIn;\n    const base = MathSol.divUpFixed(balanceIn, denominator);\n    const exponent = MathSol.divDownFixed(weightIn, weightOut);\n    const power = MathSol.powUpFixed(base, exponent, version);\n    return MathSol.mulDownFixed(balanceOut, MathSol.complementFixed(power));\n}\n\nexport function _calcInGivenOut(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountOut: bigint,\n    version?: number,\n): bigint {\n    const base = MathSol.divUpFixed(balanceOut, balanceOut - amountOut);\n    const exponent = MathSol.divUpFixed(weightOut, weightIn);\n    const power = MathSol.powUpFixed(base, exponent, version);\n    const ratio = power - WAD;\n    return MathSol.mulUpFixed(balanceIn, ratio);\n}\n","import { BasePool, BasePoolFactory } from '../';\nimport { StablePool } from './';\nimport { RawComposableStablePool, RawPool } from '../../../data/types';\n\nexport class StablePoolFactory implements BasePoolFactory {\n    public isPoolForFactory(pool: RawPool): boolean {\n        return pool.poolType === 'ComposableStable';\n    }\n\n    public create(chainId: number, pool: RawPool): BasePool {\n        return StablePool.fromRawPool(chainId, pool as RawComposableStablePool);\n    }\n}\n","import { Hex, parseEther } from 'viem';\nimport { PoolType, SwapKind } from '../../../types';\nimport { BigintIsh, Token, TokenAmount } from '../../';\nimport { BasePool } from '../';\nimport { getPoolAddress, MathSol, WAD } from '../../../utils';\nimport {\n    _calcBptInGivenExactTokensOut,\n    _calcBptOutGivenExactTokensIn,\n    _calcInGivenOut,\n    _calcOutGivenIn,\n    _calcTokenInGivenExactBptOut,\n    _calcTokenOutGivenExactBptIn,\n    _calculateInvariant,\n} from './stableMath';\nimport { RawComposableStablePool } from '../../../data/types';\n\nexport class StablePoolToken extends TokenAmount {\n    public readonly rate: bigint;\n    public readonly index: number;\n    public scale18: bigint;\n\n    public constructor(\n        token: Token,\n        amount: BigintIsh,\n        rate: BigintIsh,\n        index: number,\n    ) {\n        super(token, amount);\n        this.rate = BigInt(rate);\n        this.scale18 = (this.amount * this.scalar * this.rate) / WAD;\n        this.index = index;\n    }\n\n    public increase(amount: bigint): TokenAmount {\n        this.amount = this.amount + amount;\n        this.scale18 = (this.amount * this.scalar * this.rate) / WAD;\n        return this;\n    }\n\n    public decrease(amount: bigint): TokenAmount {\n        this.amount = this.amount - amount;\n        this.scale18 = (this.amount * this.scalar * this.rate) / WAD;\n        return this;\n    }\n}\n\nexport class StablePool implements BasePool {\n    public readonly chainId: number;\n    public readonly id: Hex;\n    public readonly address: string;\n    public readonly poolType: PoolType = PoolType.ComposableStable;\n    public readonly amp: bigint;\n    public readonly swapFee: bigint;\n    public readonly bptIndex: number;\n\n    public totalShares: bigint;\n    public tokens: StablePoolToken[];\n\n    private readonly tokenMap: Map<string, StablePoolToken>;\n    private readonly tokenIndexMap: Map<string, number>;\n\n    static fromRawPool(\n        chainId: number,\n        pool: RawComposableStablePool,\n    ): StablePool {\n        const poolTokens: StablePoolToken[] = [];\n\n        for (const t of pool.tokens) {\n            if (!t.priceRate)\n                throw new Error('Stable pool token does not have a price rate');\n            const token = new Token(\n                chainId,\n                t.address,\n                t.decimals,\n                t.symbol,\n                t.name,\n            );\n            const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);\n\n            const tokenIndex =\n                t.index ??\n                pool.tokensList.findIndex((t) => t === token.address);\n\n            poolTokens.push(\n                new StablePoolToken(\n                    token,\n                    tokenAmount.amount,\n                    parseEther(t.priceRate),\n                    tokenIndex,\n                ),\n            );\n        }\n\n        const totalShares = parseEther(pool.totalShares);\n        const amp = BigInt(pool.amp) * 1000n;\n\n        return new StablePool(\n            pool.id,\n            amp,\n            parseEther(pool.swapFee),\n            poolTokens,\n            totalShares,\n        );\n    }\n\n    constructor(\n        id: Hex,\n        amp: bigint,\n        swapFee: bigint,\n        tokens: StablePoolToken[],\n        totalShares: bigint,\n    ) {\n        this.chainId = tokens[0].token.chainId;\n        this.id = id;\n        this.address = getPoolAddress(id);\n        this.amp = amp;\n        this.swapFee = swapFee;\n        this.totalShares = totalShares;\n\n        this.tokens = tokens.sort((a, b) => a.index - b.index);\n        this.tokenMap = new Map(\n            this.tokens.map((token) => [token.token.address, token]),\n        );\n        this.tokenIndexMap = new Map(\n            this.tokens.map((token) => [token.token.address, token.index]),\n        );\n\n        this.bptIndex = this.tokens.findIndex(\n            (t) => t.token.address === this.address,\n        );\n    }\n\n    public getNormalizedLiquidity(tokenIn: Token, tokenOut: Token): bigint {\n        const tIn = this.tokenMap.get(tokenIn.wrapped);\n        const tOut = this.tokenMap.get(tokenOut.wrapped);\n\n        if (!tIn || !tOut)\n            throw new Error('Pool does not contain the tokens provided');\n        // TODO: Fix stable normalized liquidity calc\n        return tOut.amount * this.amp;\n    }\n\n    public swapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const tInIndex = this.tokenIndexMap.get(tokenIn.wrapped);\n        const tOutIndex = this.tokenIndexMap.get(tokenOut.wrapped);\n\n        if (typeof tInIndex !== 'number' || typeof tOutIndex !== 'number') {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        const balancesNoBpt = this.dropBptItem(\n            this.tokens.map((t) => t.scale18),\n        );\n\n        // TODO: Fix stable swap limit\n        if (swapAmount.scale18 > this.tokens[tInIndex].scale18) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        const invariant = _calculateInvariant(this.amp, balancesNoBpt);\n\n        let tokenOutScale18: bigint;\n        if (tokenIn.isUnderlyingEqual(this.tokens[this.bptIndex].token)) {\n            const amountInWithRate = swapAmount.mulDownFixed(\n                this.tokens[tInIndex].rate,\n            );\n\n            tokenOutScale18 = _calcTokenOutGivenExactBptIn(\n                this.amp,\n                [...balancesNoBpt],\n                this.skipBptIndex(tOutIndex),\n                amountInWithRate.scale18,\n                this.totalShares,\n                invariant,\n                this.swapFee,\n            );\n        } else if (\n            tokenOut.isUnderlyingEqual(this.tokens[this.bptIndex].token)\n        ) {\n            const amountsIn = new Array(balancesNoBpt.length).fill(0n);\n\n            const amountInWithRate = swapAmount.mulDownFixed(\n                this.tokens[tInIndex].rate,\n            );\n            amountsIn[this.skipBptIndex(tInIndex)] = amountInWithRate.scale18;\n\n            tokenOutScale18 = _calcBptOutGivenExactTokensIn(\n                this.amp,\n                [...balancesNoBpt],\n                amountsIn,\n                this.totalShares,\n                invariant,\n                this.swapFee,\n            );\n        } else {\n            const amountInWithFee = this.subtractSwapFeeAmount(swapAmount);\n            const amountInWithRate = amountInWithFee.mulDownFixed(\n                this.tokens[tInIndex].rate,\n            );\n\n            tokenOutScale18 = _calcOutGivenIn(\n                this.amp,\n                [...balancesNoBpt],\n                this.skipBptIndex(tInIndex),\n                this.skipBptIndex(tOutIndex),\n                amountInWithRate.scale18,\n                invariant,\n            );\n        }\n\n        const amountOut = TokenAmount.fromScale18Amount(\n            tokenOut,\n            tokenOutScale18,\n        );\n        const amountOutWithRate = amountOut.divDownFixed(\n            this.tokens[tOutIndex].rate,\n        );\n\n        if (amountOutWithRate.amount < 0n)\n            throw new Error('Swap output negative');\n\n        if (mutateBalances) {\n            this.tokens[tInIndex].increase(swapAmount.amount);\n            this.tokens[tOutIndex].decrease(amountOutWithRate.amount);\n\n            if (tInIndex === this.bptIndex) {\n                this.totalShares = this.totalShares - swapAmount.amount;\n            } else if (tOutIndex === this.bptIndex) {\n                this.totalShares = this.totalShares + amountOutWithRate.amount;\n            }\n        }\n\n        return amountOutWithRate;\n    }\n\n    public swapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const tInIndex = this.tokenIndexMap.get(tokenIn.wrapped);\n        const tOutIndex = this.tokenIndexMap.get(tokenOut.wrapped);\n\n        if (typeof tInIndex !== 'number' || typeof tOutIndex !== 'number') {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        const balancesNoBpt = this.dropBptItem(\n            this.tokens.map((t) => t.scale18),\n        );\n\n        // TODO: Fix stable swap limit\n        if (swapAmount.scale18 > this.tokens[tOutIndex].scale18) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        const amountOutWithRate = swapAmount.mulDownFixed(\n            this.tokens[tOutIndex].rate,\n        );\n\n        const invariant = _calculateInvariant(this.amp, balancesNoBpt);\n\n        let amountIn: TokenAmount;\n        if (tokenIn.isUnderlyingEqual(this.tokens[this.bptIndex].token)) {\n            const amountsOut = new Array(balancesNoBpt.length).fill(0n);\n            amountsOut[this.skipBptIndex(tOutIndex)] =\n                amountOutWithRate.scale18;\n\n            const tokenInScale18 = _calcBptInGivenExactTokensOut(\n                this.amp,\n                [...balancesNoBpt],\n                amountsOut,\n                this.totalShares,\n                invariant,\n                this.swapFee,\n            );\n\n            amountIn = TokenAmount.fromScale18Amount(\n                tokenIn,\n                tokenInScale18,\n                true,\n            ).divDownFixed(this.tokens[tInIndex].rate);\n        } else if (\n            tokenOut.isUnderlyingEqual(this.tokens[this.bptIndex].token)\n        ) {\n            const tokenInScale18 = _calcTokenInGivenExactBptOut(\n                this.amp,\n                [...balancesNoBpt],\n                this.skipBptIndex(tInIndex),\n                amountOutWithRate.scale18,\n                this.totalShares,\n                invariant,\n                this.swapFee,\n            );\n\n            amountIn = TokenAmount.fromScale18Amount(\n                tokenIn,\n                tokenInScale18,\n                true,\n            ).divDownFixed(this.tokens[tInIndex].rate);\n        } else {\n            const tokenInScale18 = _calcInGivenOut(\n                this.amp,\n                [...balancesNoBpt],\n                this.skipBptIndex(tInIndex),\n                this.skipBptIndex(tOutIndex),\n                amountOutWithRate.scale18,\n                invariant,\n            );\n\n            const amountInWithoutFee = TokenAmount.fromScale18Amount(\n                tokenIn,\n                tokenInScale18,\n                true,\n            );\n            const amountInWithFee = this.addSwapFeeAmount(amountInWithoutFee);\n\n            amountIn = amountInWithFee.divDownFixed(this.tokens[tInIndex].rate);\n        }\n\n        if (amountIn.amount < 0n) throw new Error('Swap output negative');\n\n        if (mutateBalances) {\n            this.tokens[tInIndex].increase(amountIn.amount);\n            this.tokens[tOutIndex].decrease(swapAmount.amount);\n\n            if (tInIndex === this.bptIndex) {\n                this.totalShares = this.totalShares - amountIn.amount;\n            } else if (tOutIndex === this.bptIndex) {\n                this.totalShares = this.totalShares + swapAmount.amount;\n            }\n        }\n\n        return amountIn;\n    }\n\n    public subtractSwapFeeAmount(amount: TokenAmount): TokenAmount {\n        const feeAmount = amount.mulUpFixed(this.swapFee);\n        return amount.sub(feeAmount);\n    }\n\n    public addSwapFeeAmount(amount: TokenAmount): TokenAmount {\n        return amount.divUpFixed(MathSol.complementFixed(this.swapFee));\n    }\n\n    public getLimitAmountSwap(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapKind: SwapKind,\n    ): bigint {\n        const tIn = this.tokenMap.get(tokenIn.address);\n        const tOut = this.tokenMap.get(tokenOut.address);\n\n        if (!tIn || !tOut)\n            throw new Error('Pool does not contain the tokens provided');\n\n        if (swapKind === SwapKind.GivenIn) {\n            // Return max valid amount of tokenIn\n            return (tIn.amount * WAD) / tIn.rate;\n        } else {\n            // Return max amount of tokenOut - approx is almost all balance\n            return (tOut.amount * WAD) / tOut.rate;\n        }\n    }\n\n    public skipBptIndex(index: number): number {\n        if (index === this.bptIndex) throw new Error('Cannot skip BPT index');\n        return index < this.bptIndex ? index : index - 1;\n    }\n\n    public dropBptItem(amounts: bigint[]): bigint[] {\n        const amountsWithoutBpt = new Array(amounts.length - 1).fill(0n);\n        for (let i = 0; i < amountsWithoutBpt.length; i++) {\n            amountsWithoutBpt[i] = amounts[i < this.bptIndex ? i : i + 1];\n        }\n        return amountsWithoutBpt;\n    }\n}\n","const AMP_PRECISION = 1000n;\nimport { MathSol, WAD } from '../../../utils/';\n\nexport function _calculateInvariant(\n    amplificationParameter: bigint,\n    balances: bigint[],\n    roundUp?: boolean,\n): bigint {\n    let sum = 0n;\n    const numTokens = balances.length;\n    for (let i = 0; i < numTokens; i++) {\n        sum += balances[i];\n    }\n\n    if (sum === 0n) {\n        return 0n;\n    }\n\n    let prevInvariant: bigint;\n    let invariant = sum;\n    const ampTimesTotal = amplificationParameter * BigInt(numTokens);\n\n    for (let i = 0; i < 255; i++) {\n        let D_P = invariant;\n\n        for (let j = 0; j < numTokens; j++) {\n            D_P = roundUp\n                ? MathSol.divUp(\n                      D_P * invariant,\n                      balances[j] * BigInt(numTokens),\n                  )\n                : (D_P * invariant) / (balances[j] * BigInt(numTokens));\n        }\n\n        prevInvariant = invariant;\n\n        invariant = roundUp\n            ? MathSol.divUp(\n                  ((ampTimesTotal * sum) / AMP_PRECISION +\n                      D_P * BigInt(numTokens)) *\n                      invariant,\n                  MathSol.divUp(\n                      (ampTimesTotal - AMP_PRECISION) * invariant,\n                      AMP_PRECISION,\n                  ) +\n                      (BigInt(numTokens) + 1n) * D_P,\n              )\n            : (((ampTimesTotal * sum) / AMP_PRECISION +\n                  D_P * BigInt(numTokens)) *\n                  invariant) /\n              (((ampTimesTotal - AMP_PRECISION) * invariant) / AMP_PRECISION +\n                  (BigInt(numTokens) + 1n) * D_P);\n\n        if (invariant > prevInvariant) {\n            if (invariant - prevInvariant <= 1n) {\n                return invariant;\n            }\n        } else if (prevInvariant - invariant <= 1n) {\n            return invariant;\n        }\n    }\n\n    throw new Error('Errors.STABLE_INVARIANT_DIDNT_CONVERGE');\n}\n\nexport function _calcOutGivenIn(\n    amplificationParameter: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    tokenAmountIn: bigint,\n    invariant: bigint,\n): bigint {\n    balances[tokenIndexIn] = balances[tokenIndexIn] + tokenAmountIn;\n\n    const finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        amplificationParameter,\n        balances,\n        invariant,\n        tokenIndexOut,\n    );\n\n    balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n    return balances[tokenIndexOut] - finalBalanceOut - 1n;\n}\n\nexport function _calcInGivenOut(\n    amplificationParameter: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    tokenAmountOut: bigint,\n    invariant: bigint,\n): bigint {\n    balances[tokenIndexOut] = balances[tokenIndexOut] - tokenAmountOut;\n\n    const finalBalanceIn = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        amplificationParameter,\n        balances,\n        invariant,\n        tokenIndexIn,\n    );\n\n    balances[tokenIndexOut] = balances[tokenIndexOut] - tokenAmountOut;\n\n    return finalBalanceIn - balances[tokenIndexIn] + 1n;\n}\n\nexport function _calcBptOutGivenExactTokensIn(\n    amp: bigint,\n    balances: bigint[],\n    amountsIn: bigint[],\n    bptTotalSupply: bigint,\n    currentInvariant: bigint,\n    swapFee: bigint,\n): bigint {\n    let sumBalances = 0n;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances += balances[i];\n    }\n\n    const balanceRatiosWithFee = new Array(amountsIn.length);\n    let invariantRatioWithFees = 0n;\n\n    for (let i = 0; i < balances.length; i++) {\n        const currentWeight = MathSol.divDownFixed(balances[i], sumBalances);\n        balanceRatiosWithFee[i] = MathSol.divDownFixed(\n            balances[i] + amountsIn[i],\n            balances[i],\n        );\n        invariantRatioWithFees =\n            invariantRatioWithFees +\n            MathSol.mulDownFixed(balanceRatiosWithFee[i], currentWeight);\n    }\n\n    const newBalances = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee: bigint;\n\n        if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                invariantRatioWithFees - WAD,\n            );\n            const taxableAmount = amountsIn[i] - nonTaxableAmount;\n\n            amountInWithoutFee =\n                nonTaxableAmount +\n                MathSol.mulDownFixed(taxableAmount, WAD - swapFee);\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n\n        newBalances[i] = balances[i] + amountInWithoutFee;\n    }\n\n    const newInvariant = _calculateInvariant(amp, newBalances);\n    const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);\n\n    if (invariantRatio > WAD) {\n        return MathSol.mulDownFixed(bptTotalSupply, invariantRatio - WAD);\n    } else {\n        return 0n;\n    }\n}\n\nexport function _calcTokenInGivenExactBptOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndex: number,\n    bptAmountOut: bigint,\n    bptTotalSupply: bigint,\n    currentInvariant: bigint,\n    swapFee: bigint,\n): bigint {\n    const newInvariant = MathSol.mulUpFixed(\n        MathSol.divUpFixed(bptTotalSupply + bptAmountOut, bptTotalSupply),\n        currentInvariant,\n    );\n\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex,\n        );\n    const amountInWithoutFee = newBalanceTokenIndex - balances[tokenIndex];\n\n    let sumBalances = 0n;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances += balances[i];\n    }\n\n    const currentWeight = MathSol.divDownFixed(\n        balances[tokenIndex],\n        sumBalances,\n    );\n    const taxablePercentage = MathSol.complementFixed(currentWeight);\n    const taxableAmount = MathSol.mulUpFixed(\n        amountInWithoutFee,\n        taxablePercentage,\n    );\n    const nonTaxableAmount = amountInWithoutFee - taxableAmount;\n\n    return nonTaxableAmount + MathSol.divUpFixed(taxableAmount, WAD - swapFee);\n}\n\nexport function _calcBptInGivenExactTokensOut(\n    amp: bigint,\n    balances: bigint[],\n    amountsOut: bigint[],\n    bptTotalSupply: bigint,\n    currentInvariant: bigint,\n    swapFee: bigint,\n): bigint {\n    let sumBalances = 0n;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances += balances[i];\n    }\n\n    const balanceRatiosWithoutFee = new Array(amountsOut.length);\n    let invariantRatioWithoutFees = 0n;\n    for (let i = 0; i < balances.length; i++) {\n        const currentWeight = MathSol.divUpFixed(balances[i], sumBalances);\n        balanceRatiosWithoutFee[i] = MathSol.divUpFixed(\n            balances[i] - amountsOut[i],\n            balances[i],\n        );\n        invariantRatioWithoutFees += MathSol.mulUpFixed(\n            balanceRatiosWithoutFee[i],\n            currentWeight,\n        );\n    }\n\n    const newBalances = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        let amountOutWithFee: bigint;\n\n        if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                MathSol.complementFixed(invariantRatioWithoutFees),\n            );\n            const taxableAmount = amountsOut[i] - nonTaxableAmount;\n\n            amountOutWithFee =\n                nonTaxableAmount +\n                MathSol.divUpFixed(taxableAmount, WAD - swapFee);\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n\n        newBalances[i] = balances[i] - amountOutWithFee;\n    }\n\n    const newInvariant = _calculateInvariant(amp, newBalances);\n    const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);\n\n    return MathSol.mulUpFixed(\n        bptTotalSupply,\n        MathSol.complementFixed(invariantRatio),\n    );\n}\n\nexport function _calcTokenOutGivenExactBptIn(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndex: number,\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint,\n    currentInvariant: bigint,\n    swapFee: bigint,\n): bigint {\n    const newInvariant = MathSol.mulUpFixed(\n        MathSol.divUpFixed(bptTotalSupply - bptAmountIn, bptTotalSupply),\n        currentInvariant,\n    );\n\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex,\n        );\n    const amountOutWithoutFee = balances[tokenIndex] - newBalanceTokenIndex;\n\n    let sumBalances = 0n;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances += balances[i];\n    }\n\n    const currentWeight = MathSol.divDownFixed(\n        balances[tokenIndex],\n        sumBalances,\n    );\n    const taxablePercentage = MathSol.complementFixed(currentWeight);\n\n    const taxableAmount = MathSol.mulUpFixed(\n        amountOutWithoutFee,\n        taxablePercentage,\n    );\n    const nonTaxableAmount = amountOutWithoutFee - taxableAmount;\n\n    return (\n        nonTaxableAmount + MathSol.mulDownFixed(taxableAmount, WAD - swapFee)\n    );\n}\n\nexport function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n    amplificationParameter: bigint,\n    balances: bigint[],\n    invariant: bigint,\n    tokenIndex: number,\n): bigint {\n    const ampTimesTotal = amplificationParameter * BigInt(balances.length);\n    let sum = balances[0];\n    let P_D = balances[0] * BigInt(balances.length);\n\n    for (let j = 1; j < balances.length; j++) {\n        P_D = (P_D * balances[j] * BigInt(balances.length)) / invariant;\n        sum += balances[j];\n    }\n\n    sum = sum - balances[tokenIndex];\n    const inv2 = invariant * invariant;\n    const c =\n        MathSol.divUp(inv2, ampTimesTotal * P_D) *\n        AMP_PRECISION *\n        balances[tokenIndex];\n    const b = sum + (invariant / ampTimesTotal) * AMP_PRECISION;\n\n    let prevTokenBalance = 0n;\n    let tokenBalance = MathSol.divUp(inv2 + c, invariant + b);\n\n    for (let i = 0; i < 255; i++) {\n        prevTokenBalance = tokenBalance;\n        tokenBalance = MathSol.divUp(\n            tokenBalance * tokenBalance + c,\n            tokenBalance * 2n + b - invariant,\n        );\n\n        if (tokenBalance > prevTokenBalance) {\n            if (tokenBalance - prevTokenBalance <= 1n) {\n                return tokenBalance;\n            }\n        } else if (prevTokenBalance - tokenBalance <= 1n) {\n            return tokenBalance;\n        }\n    }\n\n    throw new Error('Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE');\n}\n","import { BasePool, BasePoolFactory } from '..';\nimport { MetaStablePool } from '.';\nimport { RawMetaStablePool, RawPool } from '../../../data/types';\n\nexport class MetaStablePoolFactory implements BasePoolFactory {\n    public isPoolForFactory(pool: RawPool): boolean {\n        return pool.poolType === 'MetaStable';\n    }\n\n    public create(chainId: number, pool: RawPool): BasePool {\n        return MetaStablePool.fromRawPool(chainId, pool as RawMetaStablePool);\n    }\n}\n","import { Hex, parseEther } from 'viem';\nimport { PoolType, SwapKind } from '../../../types';\nimport { Token, TokenAmount } from '../..';\nimport { BasePool } from '..';\nimport { getPoolAddress, MathSol, WAD } from '../../../utils';\nimport {\n    _calcInGivenOut,\n    _calcOutGivenIn,\n    _calculateInvariant,\n} from '../stable/stableMath';\nimport { StablePoolToken } from '../stable/stablePool';\nimport { RawMetaStablePool } from '../../../data/types';\n\nexport class MetaStablePool implements BasePool {\n    public readonly chainId: number;\n    public readonly id: Hex;\n    public readonly address: string;\n    public readonly poolType: PoolType = PoolType.MetaStable;\n    public readonly amp: bigint;\n    public readonly swapFee: bigint;\n    public readonly tokens: StablePoolToken[];\n\n    private readonly tokenMap: Map<string, StablePoolToken>;\n    private readonly tokenIndexMap: Map<string, number>;\n\n    static fromRawPool(\n        chainId: number,\n        pool: RawMetaStablePool,\n    ): MetaStablePool {\n        const poolTokens: StablePoolToken[] = [];\n\n        for (const t of pool.tokens) {\n            if (!t.priceRate)\n                throw new Error(\n                    'Meta Stable pool token does not have a price rate',\n                );\n            const token = new Token(\n                chainId,\n                t.address,\n                t.decimals,\n                t.symbol,\n                t.name,\n            );\n            const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);\n\n            const tokenIndex =\n                t.index ??\n                pool.tokensList.findIndex((t) => t === token.address);\n\n            poolTokens.push(\n                new StablePoolToken(\n                    token,\n                    tokenAmount.amount,\n                    parseEther(t.priceRate),\n                    tokenIndex,\n                ),\n            );\n        }\n\n        const amp = BigInt(pool.amp) * 1000n;\n\n        return new MetaStablePool(\n            pool.id,\n            amp,\n            parseEther(pool.swapFee),\n            poolTokens,\n        );\n    }\n\n    constructor(\n        id: Hex,\n        amp: bigint,\n        swapFee: bigint,\n        tokens: StablePoolToken[],\n    ) {\n        this.chainId = tokens[0].token.chainId;\n        this.id = id;\n        this.address = getPoolAddress(id);\n        this.amp = amp;\n        this.swapFee = swapFee;\n\n        this.tokens = tokens.sort((a, b) => a.index - b.index);\n        this.tokenMap = new Map(\n            this.tokens.map((token) => [token.token.address, token]),\n        );\n        this.tokenIndexMap = new Map(\n            this.tokens.map((token) => [token.token.address, token.index]),\n        );\n    }\n\n    public getNormalizedLiquidity(tokenIn: Token, tokenOut: Token): bigint {\n        const tIn = this.tokenMap.get(tokenIn.address);\n        const tOut = this.tokenMap.get(tokenOut.address);\n\n        if (!tIn || !tOut)\n            throw new Error('Pool does not contain the tokens provided');\n        // TODO: Fix stable normalized liquidity calc\n        return tOut.amount * this.amp;\n    }\n\n    public swapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const tInIndex = this.tokenIndexMap.get(tokenIn.address);\n        const tOutIndex = this.tokenIndexMap.get(tokenOut.address);\n\n        if (typeof tInIndex !== 'number' || typeof tOutIndex !== 'number') {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        if (swapAmount.amount > this.tokens[tInIndex].amount) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        const amountInWithFee = this.subtractSwapFeeAmount(swapAmount);\n        const amountInWithRate = amountInWithFee.mulDownFixed(\n            this.tokens[tInIndex].rate,\n        );\n        const balances = this.tokens.map((t) => t.scale18);\n\n        const invariant = _calculateInvariant(this.amp, [...balances], true);\n\n        const tokenOutScale18 = _calcOutGivenIn(\n            this.amp,\n            [...balances],\n            tInIndex,\n            tOutIndex,\n            amountInWithRate.scale18,\n            invariant,\n        );\n\n        const amountOut = TokenAmount.fromScale18Amount(\n            tokenOut,\n            tokenOutScale18,\n        );\n        const amountOutWithRate = amountOut.divDownFixed(\n            this.tokens[tOutIndex].rate,\n        );\n\n        if (amountOutWithRate.amount < 0n)\n            throw new Error('Swap output negative');\n\n        if (mutateBalances) {\n            this.tokens[tInIndex].increase(swapAmount.amount);\n            this.tokens[tOutIndex].decrease(amountOutWithRate.amount);\n        }\n\n        return amountOutWithRate;\n    }\n\n    public swapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const tInIndex = this.tokenIndexMap.get(tokenIn.address);\n        const tOutIndex = this.tokenIndexMap.get(tokenOut.address);\n\n        if (typeof tInIndex !== 'number' || typeof tOutIndex !== 'number') {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        if (swapAmount.amount > this.tokens[tOutIndex].amount) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        const amountOutWithRate = swapAmount.mulDownFixed(\n            this.tokens[tOutIndex].rate,\n        );\n\n        const balances = this.tokens.map((t) => t.scale18);\n\n        const invariant = _calculateInvariant(this.amp, balances, true);\n\n        const tokenInScale18 = _calcInGivenOut(\n            this.amp,\n            [...balances],\n            tInIndex,\n            tOutIndex,\n            amountOutWithRate.scale18,\n            invariant,\n        );\n\n        const amountIn = TokenAmount.fromScale18Amount(\n            tokenIn,\n            tokenInScale18,\n            true,\n        );\n        const amountInWithFee = this.addSwapFeeAmount(amountIn);\n        const amountInWithRate = amountInWithFee.divDownFixed(\n            this.tokens[tInIndex].rate,\n        );\n\n        if (amountInWithRate.amount < 0n)\n            throw new Error('Swap output negative');\n\n        if (mutateBalances) {\n            this.tokens[tInIndex].increase(amountInWithRate.amount);\n            this.tokens[tOutIndex].decrease(swapAmount.amount);\n        }\n\n        return amountInWithRate;\n    }\n\n    public subtractSwapFeeAmount(amount: TokenAmount): TokenAmount {\n        const feeAmount = amount.mulUpFixed(this.swapFee);\n        return amount.sub(feeAmount);\n    }\n\n    public addSwapFeeAmount(amount: TokenAmount): TokenAmount {\n        return amount.divUpFixed(MathSol.complementFixed(this.swapFee));\n    }\n\n    public getLimitAmountSwap(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapKind: SwapKind,\n    ): bigint {\n        const tIn = this.tokenMap.get(tokenIn.address);\n        const tOut = this.tokenMap.get(tokenOut.address);\n\n        if (!tIn || !tOut)\n            throw new Error('Pool does not contain the tokens provided');\n\n        if (swapKind === SwapKind.GivenIn) {\n            // Return max valid amount of tokenIn\n            // As an approx - use almost the total balance of token out as we can add any amount of tokenIn and expect some back\n            return (tIn.amount * WAD) / tIn.rate;\n        } else {\n            // Return max amount of tokenOut - approx is almost all balance\n            return (tOut.amount * WAD) / tOut.rate;\n        }\n    }\n}\n","import { BasePool, BasePoolFactory } from '../';\nimport { LinearPool } from './';\nimport { RawLinearPool, RawPool } from '../../../data/types';\n\nexport class LinearPoolFactory implements BasePoolFactory {\n    public isPoolForFactory(pool: RawPool): boolean {\n        return pool.poolType.includes('Linear');\n    }\n\n    public create(chainId: number, pool: RawPool): BasePool {\n        return LinearPool.fromRawPool(chainId, pool as RawLinearPool);\n    }\n}\n","import { Hex, parseEther } from 'viem';\nimport { PoolType, SwapKind } from '../../../types';\nimport { BigintIsh, Token, TokenAmount } from '../../';\nimport { BasePool } from '../../pools';\nimport { getPoolAddress, MAX_UINT112, WAD } from '../../../utils';\nimport {\n    _calcBptOutPerMainIn,\n    _calcBptOutPerWrappedIn,\n    _calcMainOutPerBptIn,\n    _calcMainOutPerWrappedIn,\n    _calcWrappedOutPerBptIn,\n    _calcWrappedOutPerMainIn,\n    _calcMainInPerWrappedOut,\n    _calcMainInPerBptOut,\n    _calcWrappedInPerMainOut,\n    _calcWrappedInPerBptOut,\n    _calcBptInPerWrappedOut,\n    _calcBptInPerMainOut,\n} from './linearMath';\nimport { StablePoolToken } from '../stable/stablePool';\nimport { RawLinearPool } from '../../../data/types';\n\nconst ONE = parseEther('1');\nconst MAX_RATIO = parseEther('10');\nconst MAX_TOKEN_BALANCE = MAX_UINT112 - 1n;\n\ntype LinearPoolToken = BPT | StablePoolToken;\n\nclass BPT extends TokenAmount {\n    public readonly rate: bigint;\n    public readonly index: number;\n    public virtualBalance: bigint;\n\n    public constructor(token: Token, amount: BigintIsh, index: number) {\n        super(token, amount);\n        this.rate = WAD;\n        this.virtualBalance = MAX_TOKEN_BALANCE - this.amount;\n        this.index = index;\n    }\n\n    public increase(amount: bigint): TokenAmount {\n        this.amount = this.amount + amount;\n        this.virtualBalance = this.virtualBalance + amount;\n        this.scale18 = this.amount * this.scalar;\n        return this;\n    }\n\n    public decrease(amount: bigint): TokenAmount {\n        this.amount = this.amount - amount;\n        this.virtualBalance = this.virtualBalance - amount;\n        this.scale18 = this.amount * this.scalar;\n        return this;\n    }\n}\n\nexport type Params = {\n    fee: bigint;\n    rate: bigint;\n    lowerTarget: bigint;\n    upperTarget: bigint;\n};\n\nexport class LinearPool implements BasePool {\n    public readonly chainId: number;\n    public readonly id: Hex;\n    public readonly address: string;\n    public readonly poolType: PoolType = PoolType.AaveLinear;\n    public readonly poolTypeVersion: number;\n    public readonly swapFee: bigint;\n    public readonly mainToken: StablePoolToken;\n    public readonly wrappedToken: StablePoolToken;\n    public readonly bptToken: BPT;\n    public readonly params: Params;\n    public readonly tokens: LinearPoolToken[];\n\n    private readonly tokenMap: Map<string, LinearPoolToken>;\n\n    static fromRawPool(chainId: number, pool: RawLinearPool): LinearPool {\n        const orderedTokens = pool.tokens.sort((a, b) => a.index - b.index);\n        const swapFee = parseEther(pool.swapFee);\n\n        const mT = orderedTokens[pool.mainIndex];\n        const mTRate = parseEther(mT.priceRate || '1.0');\n        const mToken = new Token(\n            chainId,\n            mT.address,\n            mT.decimals,\n            mT.symbol,\n            mT.name,\n        );\n        const lowerTarget = TokenAmount.fromHumanAmount(\n            mToken,\n            pool.lowerTarget,\n        );\n        const upperTarget = TokenAmount.fromHumanAmount(\n            mToken,\n            pool.upperTarget,\n        );\n        const mTokenAmount = TokenAmount.fromHumanAmount(mToken, mT.balance);\n        const mainToken = new StablePoolToken(\n            mToken,\n            mTokenAmount.amount,\n            mTRate,\n            mT.index,\n        );\n\n        const wT = orderedTokens[pool.wrappedIndex];\n        const wTRate = parseEther(wT.priceRate || '1.0');\n\n        const wToken = new Token(\n            chainId,\n            wT.address,\n            wT.decimals,\n            wT.symbol,\n            wT.name,\n        );\n        const wTokenAmount = TokenAmount.fromHumanAmount(wToken, wT.balance);\n        const wrappedToken = new StablePoolToken(\n            wToken,\n            wTokenAmount.amount,\n            wTRate,\n            wT.index,\n        );\n\n        const bptIndex: number = orderedTokens.findIndex(\n            (t) => t.address === pool.address,\n        );\n        const bT = orderedTokens[bptIndex];\n        const bToken = new Token(\n            chainId,\n            bT.address,\n            bT.decimals,\n            bT.symbol,\n            bT.name,\n        );\n        const bTokenAmount = TokenAmount.fromHumanAmount(bToken, bT.balance);\n        const bptToken = new BPT(bToken, bTokenAmount.amount, bT.index);\n\n        const params: Params = {\n            fee: swapFee,\n            rate: wTRate,\n            lowerTarget: lowerTarget.scale18,\n            upperTarget: upperTarget.scale18,\n        };\n\n        return new LinearPool(\n            pool.id,\n            pool.poolTypeVersion,\n            params,\n            mainToken,\n            wrappedToken,\n            bptToken,\n        );\n    }\n\n    constructor(\n        id: Hex,\n        poolTypeVersion: number,\n        params: Params,\n        mainToken: StablePoolToken,\n        wrappedToken: StablePoolToken,\n        bptToken: BPT,\n    ) {\n        this.chainId = mainToken.token.chainId;\n        this.id = id;\n        this.poolTypeVersion = poolTypeVersion;\n        this.swapFee = params.fee;\n        this.mainToken = mainToken;\n        this.wrappedToken = wrappedToken;\n        this.bptToken = bptToken;\n        this.address = getPoolAddress(id);\n        this.params = params;\n\n        this.tokens = [this.mainToken, this.wrappedToken, this.bptToken];\n        this.tokenMap = new Map(\n            this.tokens.map((token) => [token.token.address, token]),\n        );\n    }\n\n    public getNormalizedLiquidity(tokenIn: Token, tokenOut: Token): bigint {\n        const tIn = this.tokenMap.get(tokenIn.wrapped);\n        const tOut = this.tokenMap.get(tokenOut.wrapped);\n\n        if (!tIn || !tOut)\n            throw new Error('Pool does not contain the tokens provided');\n        // TODO: Fix linear normalized liquidity calc\n        return tOut.amount;\n    }\n\n    public swapGivenIn(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);\n\n        let output: TokenAmount;\n        if (tokenIn.isEqual(this.mainToken.token)) {\n            if (tokenOut.isEqual(this.wrappedToken.token)) {\n                output = this._exactMainTokenInForWrappedOut(swapAmount);\n                output = output.divDownFixed(this.wrappedToken.rate);\n            } else {\n                output = this._exactMainTokenInForBptOut(swapAmount);\n            }\n        } else if (tokenIn.isEqual(this.wrappedToken.token)) {\n            swapAmount = swapAmount.mulDownFixed(this.wrappedToken.rate);\n            if (tokenOut.isEqual(this.mainToken.token)) {\n                output = this._exactWrappedTokenInForMainOut(swapAmount);\n            } else {\n                output = this._exactWrappedTokenInForBptOut(swapAmount);\n            }\n        } else if (tokenIn.isEqual(this.bptToken.token)) {\n            if (tokenOut.isEqual(this.mainToken.token)) {\n                output = this._exactBptInForMainOut(swapAmount);\n            } else {\n                output = this._exactBptInForWrappedOut(swapAmount);\n                output = output.divDownFixed(this.wrappedToken.rate);\n            }\n        } else {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        if (output.amount > (tOut?.amount || 0n)) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        if (output.amount < 0n) throw new Error('Swap amount is negative');\n\n        if (mutateBalances) {\n            tIn.increase(swapAmount.amount);\n            tOut.decrease(output.amount);\n        }\n\n        return output;\n    }\n\n    public swapGivenOut(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapAmount: TokenAmount,\n        mutateBalances?: boolean,\n    ): TokenAmount {\n        const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);\n\n        if (swapAmount.amount > (tOut?.amount || 0n)) {\n            throw new Error('Swap amount exceeds the pool limit');\n        }\n\n        let input: TokenAmount;\n        if (tokenIn.isEqual(this.mainToken.token)) {\n            if (tokenOut.isEqual(this.wrappedToken.token)) {\n                swapAmount = swapAmount.mulDownFixed(this.wrappedToken.rate);\n                input = this._mainTokenInForExactWrappedOut(swapAmount);\n            } else {\n                input = this._mainTokenInForExactBptOut(swapAmount);\n            }\n        } else if (tokenIn.isEqual(this.wrappedToken.token)) {\n            if (tokenOut.isEqual(this.mainToken.token)) {\n                input = this._wrappedTokenInForExactMainOut(swapAmount);\n            } else {\n                input = this._wrappedTokenInForExactBptOut(swapAmount);\n            }\n            input = input.mulDownFixed(this.wrappedToken.rate);\n        } else if (tokenIn.isEqual(this.bptToken.token)) {\n            if (tokenOut.isEqual(this.mainToken.token)) {\n                input = this._bptInForExactMainOut(swapAmount);\n            } else {\n                swapAmount = swapAmount.mulDownFixed(this.wrappedToken.rate);\n                input = this._bptInForExactWrappedOut(swapAmount);\n            }\n        } else {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        if (input.amount < 0n) throw new Error('Swap amount is negative');\n\n        if (mutateBalances) {\n            tIn.increase(input.amount);\n            tOut.decrease(swapAmount.amount);\n        }\n\n        return input;\n    }\n\n    public getLimitAmountSwap(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapKind: SwapKind,\n    ): bigint {\n        const tIn = this.tokenMap.get(tokenIn.wrapped);\n        const tOut = this.tokenMap.get(tokenOut.wrapped);\n\n        if (!tIn || !tOut)\n            throw new Error('Pool does not contain the tokens provided');\n\n        if (swapKind === SwapKind.GivenIn) {\n            if (tokenOut.isEqual(this.bptToken.token)) {\n                // Swapping to BPT allows for a very large amount so using pre-minted amount as estimation\n                return MAX_TOKEN_BALANCE;\n            } else {\n                const amount = TokenAmount.fromRawAmount(tokenOut, tOut.amount);\n\n                return this.swapGivenOut(tokenIn, tokenOut, amount).amount;\n            }\n        } else {\n            if (tokenOut.isEqual(this.bptToken.token)) {\n                return (tOut.amount * MAX_RATIO) / ONE;\n            } else {\n                return tOut.amount;\n            }\n        }\n    }\n\n    private _exactMainTokenInForWrappedOut(\n        swapAmount: TokenAmount,\n    ): TokenAmount {\n        const tokenOutScale18 = _calcWrappedOutPerMainIn(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.wrappedToken.token,\n            tokenOutScale18,\n        );\n    }\n\n    private _exactMainTokenInForBptOut(swapAmount: TokenAmount): TokenAmount {\n        const tokenOutScale18 = _calcBptOutPerMainIn(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.bptToken.token,\n            tokenOutScale18,\n        );\n    }\n\n    private _exactWrappedTokenInForMainOut(\n        swapAmount: TokenAmount,\n    ): TokenAmount {\n        const tokenOutScale18 = _calcMainOutPerWrappedIn(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.mainToken.token,\n            tokenOutScale18,\n        );\n    }\n\n    private _exactWrappedTokenInForBptOut(\n        swapAmount: TokenAmount,\n    ): TokenAmount {\n        const tokenOutScale18 = _calcBptOutPerWrappedIn(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.bptToken.token,\n            tokenOutScale18,\n        );\n    }\n\n    private _exactBptInForMainOut(swapAmount: TokenAmount): TokenAmount {\n        const tokenOutScale18 = _calcMainOutPerBptIn(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.mainToken.token,\n            tokenOutScale18,\n        );\n    }\n\n    private _exactBptInForWrappedOut(swapAmount: TokenAmount): TokenAmount {\n        const tokenOutScale18 = _calcWrappedOutPerBptIn(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.wrappedToken.token,\n            tokenOutScale18,\n        );\n    }\n\n    private _mainTokenInForExactWrappedOut(\n        swapAmount: TokenAmount,\n    ): TokenAmount {\n        const tokenOutScale18 = _calcMainInPerWrappedOut(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.mainToken.token,\n            tokenOutScale18,\n            true,\n        );\n    }\n\n    private _mainTokenInForExactBptOut(swapAmount: TokenAmount): TokenAmount {\n        const tokenOutScale18 = _calcMainInPerBptOut(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.mainToken.token,\n            tokenOutScale18,\n            true,\n        );\n    }\n\n    private _wrappedTokenInForExactMainOut(\n        swapAmount: TokenAmount,\n    ): TokenAmount {\n        const tokenOutScale18 = _calcWrappedInPerMainOut(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.wrappedToken.token,\n            tokenOutScale18,\n            true,\n        );\n    }\n\n    private _wrappedTokenInForExactBptOut(\n        swapAmount: TokenAmount,\n    ): TokenAmount {\n        const tokenOutScale18 = _calcWrappedInPerBptOut(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.wrappedToken.token,\n            tokenOutScale18,\n            true,\n        );\n    }\n\n    private _bptInForExactMainOut(swapAmount: TokenAmount): TokenAmount {\n        const tokenOutScale18 = _calcBptInPerMainOut(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.bptToken.token,\n            tokenOutScale18,\n            true,\n        );\n    }\n\n    private _bptInForExactWrappedOut(swapAmount: TokenAmount): TokenAmount {\n        const tokenOutScale18 = _calcBptInPerWrappedOut(\n            swapAmount.scale18,\n            this.mainToken.scale18,\n            this.wrappedToken.scale18,\n            this.bptToken.virtualBalance,\n            this.params,\n        );\n\n        return TokenAmount.fromScale18Amount(\n            this.bptToken.token,\n            tokenOutScale18,\n            true,\n        );\n    }\n\n    private getRequiredTokenPair(\n        tokenIn: Token,\n        tokenOut: Token,\n    ): { tIn: LinearPoolToken; tOut: LinearPoolToken } {\n        const tIn = this.tokenMap.get(tokenIn.wrapped);\n        const tOut = this.tokenMap.get(tokenOut.wrapped);\n\n        if (!tIn || !tOut) {\n            throw new Error('Pool does not contain the tokens provided');\n        }\n\n        return { tIn, tOut };\n    }\n}\n","import { MathSol, WAD } from '../../../utils/';\nimport { Params } from './';\n\nexport function _calcWrappedOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    params: Params,\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance + mainIn, params);\n\n    return afterNominalMain - previousNominalMain;\n}\n\nexport function _calcBptOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    // Amount out, so we round down overall.\n\n    if (bptSupply === 0n) {\n        return _toNominal(mainIn, params);\n    }\n\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance + mainIn, params);\n    const deltaNominalMain = afterNominalMain - previousNominalMain;\n    const invariant = _calcInvariant(previousNominalMain, wrappedBalance);\n\n    return (bptSupply * deltaNominalMain) / invariant;\n}\n\nexport function _calcMainOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    params: Params,\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = previousNominalMain - wrappedIn;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n\n    return mainBalance - newMainBalance;\n}\n\nexport function _calcBptOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    if (bptSupply === 0n) {\n        return wrappedIn;\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);\n    const newWrappedBalance = wrappedBalance + wrappedIn;\n    const newInvariant = _calcInvariant(nominalMain, newWrappedBalance);\n    const newBptBalance = (bptSupply * newInvariant) / previousInvariant;\n\n    return newBptBalance - bptSupply;\n}\n\nexport function _calcMainOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariant(previousNominalMain, wrappedBalance);\n    const deltaNominalMain = (invariant * bptIn) / bptSupply;\n    const afterNominalMain = previousNominalMain - deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n\n    return mainBalance - newMainBalance;\n}\n\nexport function _calcWrappedOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);\n    const newBptBalance = bptSupply - bptIn;\n    const newWrappedBalance =\n        (newBptBalance * previousInvariant) / bptSupply - nominalMain;\n\n    return wrappedBalance - newWrappedBalance;\n}\n\nexport function _calcMainInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    params: Params,\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = previousNominalMain + wrappedOut;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n\n    return newMainBalance - mainBalance;\n}\n\nexport function _calcMainInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    if (bptSupply === 0n) {\n        return _fromNominal(bptOut, params);\n    }\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariant(previousNominalMain, wrappedBalance);\n    const deltaNominalMain = (invariant * bptOut) / bptSupply;\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n\n    return newMainBalance - mainBalance;\n}\n\nexport function _calcWrappedInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    params: Params,\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance - mainOut, params);\n\n    return previousNominalMain - afterNominalMain;\n}\n\nexport function _calcWrappedInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    if (bptSupply === 0n) {\n        return bptOut;\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);\n    const newBptBalance = bptSupply + bptOut;\n    const newWrappedBalance =\n        (newBptBalance * previousInvariant) / bptSupply - nominalMain;\n\n    return newWrappedBalance - wrappedBalance;\n}\n\nexport function _calcBptInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);\n    const newWrappedBalance = wrappedBalance - wrappedOut;\n    const newInvariant = _calcInvariant(nominalMain, newWrappedBalance);\n    const newBptBalance = (bptSupply * newInvariant) / previousInvariant;\n\n    return bptSupply - newBptBalance;\n}\n\nexport function _calcBptInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params,\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance - mainOut, params);\n    const deltaNominalMain = previousNominalMain - afterNominalMain;\n    const invariant = _calcInvariant(previousNominalMain, wrappedBalance);\n\n    return (bptSupply * deltaNominalMain) / invariant;\n}\n\nfunction _calcInvariant(\n    nominalMainBalance: bigint,\n    wrappedBalance: bigint,\n): bigint {\n    return nominalMainBalance + wrappedBalance;\n}\n\nfunction _toNominal(real: bigint, params: Params): bigint {\n    // Fees are always rounded down: either direction would work but we need to be consistent, and rounding down\n    // uses less gas.\n    if (real < params.lowerTarget) {\n        const fees = MathSol.mulDownFixed(\n            params.lowerTarget - real,\n            params.fee,\n        );\n        return real - fees;\n    } else if (real <= params.upperTarget) {\n        return real;\n    } else {\n        const fees = MathSol.mulDownFixed(\n            real - params.upperTarget,\n            params.fee,\n        );\n        return real - fees;\n    }\n}\n\nfunction _fromNominal(nominal: bigint, params: Params): bigint {\n    // Since real = nominal + fees, rounding down fees is equivalent to rounding down real.\n    if (nominal < params.lowerTarget) {\n        return MathSol.divDownFixed(\n            nominal + MathSol.mulDownFixed(params.fee, params.lowerTarget),\n            WAD + params.fee,\n        );\n    } else if (nominal <= params.upperTarget) {\n        return nominal;\n    } else {\n        return MathSol.divDownFixed(\n            nominal - MathSol.mulDownFixed(params.fee, params.upperTarget),\n            WAD - params.fee,\n        );\n    }\n}\n","import { BasePool, BasePoolFactory } from './';\nimport { WeightedPoolFactory } from './weighted';\nimport { StablePoolFactory } from './stable';\nimport { MetaStablePoolFactory } from './metastable';\nimport { LinearPoolFactory } from './linear';\nimport { RawPool } from '../../data/types';\n\nexport class PoolParser {\n    private readonly poolFactories: BasePoolFactory[];\n    private readonly chainId: number;\n    constructor(chainId: number, customPoolFactories: BasePoolFactory[]) {\n        this.chainId = chainId;\n        this.poolFactories = [\n            // custom pool factories take precedence over base factories\n            ...customPoolFactories,\n            new WeightedPoolFactory(),\n            new StablePoolFactory(),\n            new MetaStablePoolFactory(),\n            new LinearPoolFactory(),\n        ];\n    }\n\n    public parseRawPools(rawPools: RawPool[]): BasePool[] {\n        const pools: BasePool[] = [];\n\n        for (const rawPool of rawPools) {\n            for (const factory of this.poolFactories) {\n                if (factory.isPoolForFactory(rawPool)) {\n                    pools.push(factory.create(this.chainId, rawPool));\n\n                    break;\n                }\n            }\n        }\n\n        return pools;\n    }\n}\n","import {\n    GetPoolsResponse,\n    PoolDataEnricher,\n    PoolDataProvider,\n    ProviderSwapOptions,\n    RawPool,\n} from './types';\nimport { createPublicClient, http } from 'viem';\n\nexport class PoolDataService {\n    constructor(\n        private readonly providers: PoolDataProvider[],\n        private readonly enrichers: PoolDataEnricher[],\n        private readonly rpcUrl: string,\n    ) {}\n\n    public async fetchEnrichedPools(\n        blockNumber?: bigint,\n    ): Promise<{ rawPools: RawPool[]; providerData: GetPoolsResponse }> {\n        const providerOptions: ProviderSwapOptions = {\n            block: blockNumber,\n            timestamp: await this.getTimestampForBlockNumber(blockNumber),\n        };\n\n        //TODO: might be necessary to remove duplicates, decide which take precendence\n        const responses = await Promise.all(\n            this.providers.map((provider) =>\n                provider.getPools(providerOptions),\n            ),\n        );\n\n        const providerData: GetPoolsResponse = {\n            pools: responses.flatMap((response) => response.pools),\n            //we take the smallest block number from the set\n            syncedToBlockNumber: responses\n                .map((response) => response.syncedToBlockNumber || 0n)\n                .sort()[0],\n            poolsWithActiveWeightUpdates: responses.flatMap(\n                (response) => response.poolsWithActiveWeightUpdates || [],\n            ),\n            poolsWithActiveAmpUpdates: responses.flatMap(\n                (response) => response.poolsWithActiveAmpUpdates || [],\n            ),\n        };\n\n        return {\n            rawPools: await this.enrichPools(providerData, providerOptions),\n            providerData,\n        };\n    }\n\n    public async enrichPools(\n        data: GetPoolsResponse,\n        providerOptions: ProviderSwapOptions,\n    ) {\n        let pools = data.pools;\n\n        const additionalPoolData = await Promise.all(\n            this.enrichers.map((provider) =>\n                provider.fetchAdditionalPoolData(data, providerOptions),\n            ),\n        );\n\n        // We enrich the pools in order of the enrichers array\n        for (let i = 0; i < this.enrichers.length; i++) {\n            pools = this.enrichers[i].enrichPoolsWithData(\n                pools,\n                additionalPoolData[i],\n            );\n        }\n\n        return pools;\n    }\n\n    public async getTimestampForBlockNumber(blockNumber?: bigint) {\n        if (blockNumber) {\n            const client = createPublicClient({\n                transport: http(this.rpcUrl),\n            });\n\n            return (await client.getBlock({ blockNumber })).timestamp;\n        } else {\n            return BigInt(Math.floor(new Date().getTime() / 1000));\n        }\n    }\n}\n","import { Router } from './router';\nimport { BasePool, Path, Token, TokenAmount, Swap } from './entities';\nimport {\n    BALANCER_SOR_QUERIES_ADDRESS,\n    ChainId,\n    checkInputs,\n    SUBGRAPH_URLS,\n} from './utils';\nimport { SorConfig, SwapInputRawAmount, SwapKind, SwapOptions } from './types';\nimport { PoolParser } from './entities/pools/parser';\nimport { OnChainPoolDataEnricher, SubgraphPoolProvider } from './data';\nimport { PoolDataService } from './data/poolDataService';\nimport { GetPoolsResponse } from './data/types';\n\nexport class SmartOrderRouter {\n    private readonly chainId: ChainId;\n    private readonly router: Router;\n    private readonly poolParser: PoolParser;\n    private readonly poolDataService: PoolDataService;\n    private pools: BasePool[] = [];\n    private blockNumber: bigint | null = null;\n    private poolsProviderData: GetPoolsResponse | null = null;\n\n    constructor({\n        chainId,\n        rpcUrl,\n        poolDataProviders,\n        poolDataEnrichers,\n        customPoolFactories = [],\n    }: SorConfig) {\n        this.chainId = chainId;\n        this.router = new Router();\n        this.poolParser = new PoolParser(chainId, customPoolFactories);\n        poolDataProviders =\n            poolDataProviders ||\n            new SubgraphPoolProvider(chainId, SUBGRAPH_URLS[chainId]);\n        poolDataEnrichers =\n            poolDataEnrichers ||\n            new OnChainPoolDataEnricher(rpcUrl, BALANCER_SOR_QUERIES_ADDRESS);\n        this.poolDataService = new PoolDataService(\n            Array.isArray(poolDataProviders)\n                ? poolDataProviders\n                : [poolDataProviders],\n            Array.isArray(poolDataEnrichers)\n                ? poolDataEnrichers\n                : [poolDataEnrichers],\n            rpcUrl,\n        );\n    }\n\n    public async fetchAndCachePools(blockNumber?: bigint): Promise<BasePool[]> {\n        const { rawPools, providerData } =\n            await this.poolDataService.fetchEnrichedPools(blockNumber);\n        this.pools = this.poolParser.parseRawPools(rawPools);\n        this.blockNumber = typeof blockNumber === 'bigint' ? blockNumber : null;\n        this.poolsProviderData = providerData;\n\n        return this.pools;\n    }\n\n    public async fetchAndCacheLatestPoolEnrichmentData(blockNumber?: bigint) {\n        if (!this.poolsProviderData) {\n            throw new Error(\n                'fetchAndCacheLatestPoolEnrichmentData can only be called after a successful call to fetchAndCachePools',\n            );\n        }\n\n        const providerOptions = {\n            block: blockNumber,\n            timestamp: await this.poolDataService.getTimestampForBlockNumber(\n                blockNumber,\n            ),\n        };\n\n        const enriched = await this.poolDataService.enrichPools(\n            this.poolsProviderData,\n            providerOptions,\n        );\n        this.pools = this.poolParser.parseRawPools(enriched);\n    }\n\n    public get isInitialized(): boolean {\n        return this.pools.length > 0;\n    }\n\n    public async getSwaps(\n        tokenIn: Token,\n        tokenOut: Token,\n        swapKind: SwapKind,\n        swapAmount: SwapInputRawAmount | TokenAmount,\n        swapOptions?: SwapOptions,\n    ): Promise<Swap | null> {\n        swapAmount = checkInputs(tokenIn, tokenOut, swapKind, swapAmount);\n        const candidatePaths = await this.getCandidatePaths(\n            tokenIn,\n            tokenOut,\n            swapOptions,\n        );\n\n        const bestPaths = this.router.getBestPaths(\n            candidatePaths,\n            swapKind,\n            swapAmount,\n        );\n\n        if (!bestPaths) return null;\n\n        return new Swap({ paths: bestPaths, swapKind });\n    }\n\n    public async getCandidatePaths(\n        tokenIn: Token,\n        tokenOut: Token,\n        options?: Pick<SwapOptions, 'block' | 'graphTraversalConfig'>,\n    ): Promise<Path[]> {\n        // fetch pools if we haven't yet, or if a block number is provided that doesn't match the existing.\n        if (\n            !this.isInitialized ||\n            (options?.block && options.block !== this.blockNumber)\n        ) {\n            await this.fetchAndCachePools(options?.block);\n        }\n\n        return this.router.getCandidatePaths(\n            tokenIn,\n            tokenOut,\n            this.pools,\n            options?.graphTraversalConfig,\n        );\n    }\n}\n","import { RawPool } from './data';\nimport {\n    BasePool,\n    BasePoolFactory,\n    Swap,\n    Token,\n    TokenAmount,\n} from './entities';\nimport { PoolParser } from './entities/pools/parser';\nimport { SwapInputRawAmount, SwapKind, SwapOptions } from './types';\nimport { ChainId, checkInputs } from './utils';\nimport { Router } from './router';\n\nexport function sorParseRawPools(\n    chainId: ChainId,\n    pools: RawPool[],\n    customPoolFactories: BasePoolFactory[] = [],\n): BasePool[] {\n    const poolParser = new PoolParser(chainId, customPoolFactories);\n\n    return poolParser.parseRawPools(pools);\n}\n\nexport async function sorGetSwapsWithPools(\n    tokenIn: Token,\n    tokenOut: Token,\n    swapKind: SwapKind,\n    swapAmount: SwapInputRawAmount | TokenAmount,\n    pools: BasePool[],\n    swapOptions?: Omit<SwapOptions, 'graphTraversalConfig.poolIdsToInclude'>,\n): Promise<Swap | null> {\n    swapAmount = checkInputs(tokenIn, tokenOut, swapKind, swapAmount);\n    const router = new Router();\n\n    const candidatePaths = router.getCandidatePaths(\n        tokenIn,\n        tokenOut,\n        pools,\n        swapOptions?.graphTraversalConfig,\n    );\n    const bestPaths = router.getBestPaths(candidatePaths, swapKind, swapAmount);\n\n    if (!bestPaths) return null;\n\n    return new Swap({ paths: bestPaths, swapKind });\n}\n"],"mappings":"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","names":["createPublicClient","http","ChainId","PoolType","SwapKind","createPublicClient","http","fetch","parseEther","_calcOutGivenIn","_calcInGivenOut","t","parseEther","_calcOutGivenIn","_calcInGivenOut","parseEther","t","parseEther","_calcOutGivenIn","_calcInGivenOut","parseEther","parseEther","createPublicClient","http"]}